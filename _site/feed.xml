<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wbq&apos;s Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 12 Nov 2021 17:01:15 +0800</pubDate>
    <lastBuildDate>Fri, 12 Nov 2021 17:01:15 +0800</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>浅谈区块链（一）</title>
        <description>&lt;p&gt;这篇文章本来是发在简书，发出去的一刻，直接被锁，只能自己可见，估计是文章关键字扫到了，看来目前国内对这个管控还是挺严。
话说很早就开始玩币了，从17年开始，从来没有赚过钱，当时是在网上冲浪发现这个东西，下了个火币来玩一玩，买了500块eos，事实证明eos到现在还是那个鸟样。这几天心血来潮，想要系统性地学习一下区块链的知识，再好好去研究一下别的项目，区块链的知识量真的是太大了，先总结第一篇，方便自己后续回顾。&lt;/p&gt;

&lt;h3 id=&quot;比特币的交易挖矿原理&quot;&gt;比特币的交易、挖矿原理&lt;/h3&gt;

&lt;p&gt;现实生活中当A给B转钱的时候，一定会产生一条记录，不管任何的金融系统都需要记录这一条记录。但众所周知虚拟货币的第一大亮点就是去中心化，什么是去中心化？&lt;/p&gt;

&lt;p&gt;在支付宝中A给B转钱，支付宝的系统会负责完成这一笔交易并且记录这一条记录，这就是中心化，中心化的特点就是A跟B的交易需要支付宝这个第三方来介入，否则这比交易将无法完成。银行转账一样的道理。&lt;/p&gt;

&lt;p&gt;那么比特币是如何完成这一笔交易的，并且记账的呢？&lt;/p&gt;

&lt;p&gt;这里先引出一个概念，比特币客户端本质上来说是一个应用，跑在计算机上的应用，类似于在centOS上起了一个JavaWeb程序，目前世界上有上百万台计算机运行着这个应用，就是我们俗称的矿机。&lt;/p&gt;

&lt;p&gt;当A通过比特币客户端（钱包，轻应用）给B转钱，客户端会广播这条信息到全网的比特币客户端，所有的节点一起来记账，把这条记录先记录到自己的内存中，每台计算机都会把最近一段时间收到的交易进行打包形成一个区块，拼到上一次打包的区块上，类似于链表结构，形成了一个区块链。&lt;/p&gt;

&lt;p&gt;1.因为记账只有唯一一台机器可以记这几分钟的账，第一个问题，那么多节点同时计算，谁说了算？&lt;/p&gt;

&lt;p&gt;打包的过程是将 最近有效的交易 + 时间戳 + 随机数 通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sha256&lt;/code&gt;计算出一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashcode&lt;/code&gt;，当这个值符合前几位为0的时候，这台机器就有资格进行打包，把最近这些交易进行打包记账，那么相应的，系统会给予奖励，这个奖励是打包过程中，节点自动同时会把这笔交易加入到计算当中，这就是挖矿。系统会动态地调整计算难度，确保在10分钟左右出一个块，截止到目前是必须符合前19个是0。&lt;/p&gt;

&lt;p&gt;2.这么多机器，一台客户端广播得过来吗？&lt;/p&gt;

&lt;p&gt;据不完全统计目前的全网节点只需要12秒就可以同步90%的节点，广播的效率相比于打包的过程还是相当快的，相比与真正耗时的是计算那个hashcode。而且不需要全节点广播，只需要广播就近几个节点，通过传递很快可以广播到全网。&lt;/p&gt;

&lt;p&gt;3.关于余额的计算&lt;/p&gt;

&lt;p&gt;在比特币的网络中没有余额的概念，而是通过纯计算得出。假如我想知道某个钱包的余额，只需要计算在链条上所有关该钱包的收款记录就能动态计算出我目前的余额了。每条交易的模型在BTC中称为UTXO。有一个输入一个输出。每个UTXO中输入方是花费方，输出方是消费方，每一个输出都犹如现实中的一张纸币，他只有两种状态，属于你或者不属于你。未花费就是该张纸币属于你，已花费就是该张纸币不属于你。每一个 UTXO 和纸币一样，只可能有两种状态，要么是没有被花费的，要么就是已经被花费，所有权变成了其他人或者地址，成为其他地址的 UTXO。如果A有10个BTC，转给B10个，那么就是一个UTXO。如果转5个那么就是两个UTXO，因为存在找零操作。一个UTXO是A-&amp;gt;B 5个BTC ，一个是UTXO是A-&amp;gt;A 5个BTC .&lt;/p&gt;

&lt;p&gt;4.为什么说不可篡改&lt;/p&gt;

&lt;p&gt;这就是公有链的价值所在，假设说中心化的金融系统是可以随意篡改的话，那么去中心化的区块链相对来说是非常安全的。首先在中心化的系统中，改一条数据神不知鬼不觉，参考蚂蚁的员工把自己的余额后面加了两个0。在区块链中，每个区块的整个所有的信息都会有个hashcode。每个块都会保存前一个块的hashcode。又因为记账是大家一起记，假设你在你的节点把其中几个块改了，庞大的系统是不认可你的，因为剩下99.9999…%的节点记是正确的数据，只有你一个是错误，你这条链是不会有人继续往下写的，这就是共识的力量。在公有链中，除非你有绝对的实力可以改掉一半以上的机器数据，当然能做到这一点的人也不屑于做修改数据来增加自己的财富。&lt;/p&gt;

&lt;p&gt;5.BTC的劣势&lt;/p&gt;

&lt;p&gt;一.因为由于系统设计的问题，导致BTC的交易TPS相当慢，一秒钟只能发起7笔左右的交易，这在当今这个高速的互联网是根本无法满足需求的。&lt;/p&gt;

&lt;p&gt;二.由于BTC挖矿的机制是POW，所以就造成了电力和资源的浪费，多个矿池都在做同样一件事，而真正生产的价值的只有那么几台。&lt;/p&gt;

&lt;h3 id=&quot;关于交易所&quot;&gt;关于交易所&lt;/h3&gt;

&lt;p&gt;交易所本质是一个中心化的系统，他只有唯一一个钱包地址。所以其实在里面所有的交易，都是基于他自己的数据库，你的挂单，你的买币其实都是他数据库里的加加减减。这也就是解释了，为什么BTC这么慢的TPS，在交易所每秒却有成百上千的挂单成交。&lt;/p&gt;

&lt;p&gt;因为每个钱包余额都是透明的，所以你可以看到头部的钱包基本都是交易所的钱包。&lt;/p&gt;

&lt;p&gt;交易所其实是个很坑的东西，首先挂单交易都需要手续费，你划转到钱包需要手续费。而且你在交易所的币实际上都在他的钱包里，理论上他可以拿你的钱做任何的事。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;系统地了解完BTC的整个机制之后，感叹这确实不像十多年前设计的东西，思路真的太超前了，当我们还在拼命寻求一个公平公开透明的中心化机制的时候，设计者已经开创了一个这样的自由公开透明的国度。虽然我觉得设计者在设计之初一定没想到在十几年后的今年，BTC会对世界产生这么大的影响。现如今在加密货币的世界中，所有的项目都是在此基础之上进行搭建改造的。这真是一门另人着迷的技术啊。&lt;/p&gt;

</description>
        <pubDate>Thu, 11 Nov 2021 14:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/11/11/%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/11/11/%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE-%E4%B8%80/</guid>
        
        <category>Blockchain</category>
        
        
      </item>
    
      <item>
        <title>Xcode13.0 iOS15 debug异常崩溃</title>
        <description>&lt;p&gt;早上应用各种崩溃，一个应用WKWebiew莫名崩溃、另一个则是起都起不来。只要不是处于调试模式下都OK，即便是从模拟器点开app。分析了半天还是同事告知是苹果出了问题….&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes/&quot;&gt;iOS &amp;amp; iPadOS 15 Release Notes&lt;/a&gt;
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-e58ca44985dd5d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;临时解决办法&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Workaround: In Xcode, select Product &amp;gt; Scheme &amp;gt; Edit Scheme, 
then deselect Run &amp;gt; Options &amp;gt; Queue Debugging &amp;gt; “Enable backtrace recording.”
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;先这么的，乖乖等13.1吧 - - 。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/10/12/xcodebug/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/10/12/xcodebug/</guid>
        
        <category>Xcode</category>
        
        
      </item>
    
      <item>
        <title>如何设计一个好的WebView容器</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;众所周知，iOS的网页组件很封闭，基本就是基于WKWebview修修改改。看起来能做的不多，但是一个好的webview容器，其实能做的事情还有很多。今天想聊一下，一个好的webview的容器，除了自己本身的功能，还需要哪些设计。&lt;/p&gt;

&lt;h3 id=&quot;1jsbridge的设计&quot;&gt;1.jsbridge的设计&lt;/h3&gt;

&lt;p&gt;wk很容易就可以使用jsbridge，只要在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configuration.userContentController&lt;/code&gt;注入调用名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)addScriptMessageHandler:(id &amp;lt;WKScriptMessageHandler&amp;gt;)scriptMessageHandler name:(NSString *)name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js中附上刚面的name就可以调用了，非常方便&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;window.webkit.messageHandlers.name.postMessage()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时也可以在想要的时间点（一般在初始过程）注入JS。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;
[userContentController addUserScript:[[WKUserScript alloc] initWithSource:script
																		injectionTime:WKUserScriptInjectionTimeAtDocumentStart
																	 forMainFrameOnly:YES]];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;健全的容器，需要健全的bridge方法，比如容器的版本，基础的设备信息等等。业务功能比如照片选择器、图片浏览器、原生扫码页、蓝牙等等，都可以按需加入。当然光提供bridge，几个还好，一旦多起来，他们就需要体系，接收方法需要统一入口，交由容器解析，有一套健全的派发逻辑，因为native的方法代码可能散落在工程各处。返回结果需要统一出口，由容器统一格式返回。&lt;/p&gt;

&lt;p&gt;而在js端调用的过程中需要规范调用的格式，入参的规则，成功和失败的回调规则。当native执行完毕之后，需要告知js侧结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-b6d429e033c16206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image-20210903110547976.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2同层渲染&quot;&gt;2.同层渲染&lt;/h3&gt;

&lt;p&gt;让网页拥有原生组件的能力，这是近两年比较火的同层渲染技术。&lt;/p&gt;

&lt;p&gt;市面上的实现原理也已经比较成熟，具体实现可以看微信这篇&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813&quot;&gt;小程序同层渲染原理剖析&lt;/a&gt;写的非常详细。&lt;/p&gt;

&lt;p&gt;github上也有相关的源码级别实现。iOS的做法来说相对来说“trick”一些，而android在实现上会更加复杂一点。&lt;/p&gt;

&lt;h3 id=&quot;3离线加载&quot;&gt;3.离线加载&lt;/h3&gt;

&lt;p&gt;故名思议通过加载本地的资源进行网页的渲染，达到网页秒开的效果。&lt;/p&gt;

&lt;p&gt;在这其中，资源的动态的下发是比较重要的一环，下发的时间点，如何正确的命中用户都是需要做的课题。后续数据的追溯，命中情况等都需要监控。&lt;/p&gt;

&lt;p&gt;当然，资源的管理是一方面，如果正确识别需要加载的URL绕过网络去加载本地的资源的这个过程同样需要精细化设计。WKWebView的请求拦截，网上基本说烂了，这篇文章基本是结贴&lt;a href=&quot;https://juejin.cn/post/6922625242796032007&quot;&gt;WKWebView 请求拦截探索与实践&lt;/a&gt;。市面上思路都差不多，”WKWebView不支持http、https拦截”、”Body丢失”、”Cookie同步”这些问题只要花时间都是有解的。&lt;/p&gt;

&lt;p&gt;补充：关于body丢失的问题，不管是用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSURLProtocol&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WKURLSchemeHandler&lt;/code&gt;，基本都是需要js端配合hook &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XMLHTTPRequest&lt;/code&gt;，只需在容器启动从native注入hook的js，对前端同学同样也是透明的，没有负担。&lt;/p&gt;

&lt;h3 id=&quot;4性能稳定监控&quot;&gt;4.性能稳定监控&lt;/h3&gt;

&lt;p&gt;基本的性能监控不能少，统计网页从打开到显示的时间，网页加载完毕时候统计是否是白屏等等。&lt;/p&gt;

&lt;p&gt;也可以通过一些网页的属性传给网页进行统计比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;window.performance&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;补充：白屏的几种判别方法:1.截图像素点的判断。2.遍历dom节点查看是否有正常子节点。&lt;/p&gt;

&lt;h3 id=&quot;5预热&quot;&gt;5.预热&lt;/h3&gt;

&lt;p&gt;今日头条的详情页部分是通过WKWebView进行渲染的，好的用户体验的一个很重要的点就是wk的预热和复用，详见参考中的链接。&lt;/p&gt;

&lt;h3 id=&quot;6其他&quot;&gt;6.其他&lt;/h3&gt;

&lt;p&gt;大的块暂时能想到的就这么多，剩下的定制化功能其实还有很多，开发者可以不断地往上垒，治理好bridge是关键，比如容器可以支持查看js日志，并且在线调试，增加一些对navibar，navibaritem，横屏，手势等进行设置的功能，又比如将网页一些耗时任务交给native处理，在体验上也会有不错的效果。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;相比于flutter，我其实更崇尚基于native + h5的这种hybrid开发，随着h5的体验越来越好，其实这种开发方式已经是目前主流的开发模式了，不管是从效率、易用、容错等方面都是一个相当不错的选择。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Xqr6rQBbx7XPoBESEFuXJw&quot;&gt;今日头条品质优化 - 图文详情页秒开实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813&quot;&gt;小程序同层渲染原理剖析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6922625242796032007&quot;&gt;WKWebView 请求拦截探索与实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Naituw/WBWebViewConsole&quot;&gt;WBWebViewConsole&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/06/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84webview%E5%AE%B9%E5%99%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/06/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84webview%E5%AE%B9%E5%99%A8/</guid>
        
        <category>WKWebView</category>
        
        
      </item>
    
      <item>
        <title>聊聊热更新</title>
        <description>&lt;p&gt;想写这篇文章挺久了，今天我们来聊一聊热更新。&lt;/p&gt;

&lt;h2 id=&quot;0x01前言&quot;&gt;0x01.前言&lt;/h2&gt;

&lt;p&gt;国内开发者对于热更新不可谓不热衷，前仆后继地发明一个又一个新思路，我自己也是对热更新特别感兴趣，尤其对iOS来说，这更是一片敏感的灰色地带，自从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jspatch&lt;/code&gt;被苹果警告之后，各家公司的热更需求依然没有减弱，因此这个话题变得相当微妙，各家公司都有一些自己的方案，并且不再开源，因为开源意味着会像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jspatch&lt;/code&gt;一样变成把子，业界最著名的&lt;a href=&quot;https://github.com/DynamicCocoa/DynamicCocoa&quot;&gt;DynamicCocoa&lt;/a&gt;就是一个非常典型的例子，时至今日，再去打开这个仓库的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;issue&lt;/code&gt;依然会让你捧腹大笑。&lt;/p&gt;

&lt;h2 id=&quot;0x02演进过程&quot;&gt;0x02.演进过程&lt;/h2&gt;

&lt;p&gt;其实一路走来我对热更新演进过程的总结就是两个字 —— &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;内卷&lt;/code&gt;，虽然这两个戏谑的字不是那么合适，但事实就是如此，热更的方案变得更加多元化，防审核能力也变得更强。开发大佬们也已经不再局限于现成的脚本语言，转而自己去开发新的脚本语言。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-faa88b51c33c7d02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;演进过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;众所周知一个apple应用是静态编译成二进制文件的(AOT)，在线上去修改此类文件是不现实的，因此就需要用到脚本语言（JIT）+  动态化语言的能力，这就是热更的本质。几乎所有热更的流程基本都符合下面这张流程图的逻辑（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactNative &lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Weex&lt;/code&gt;等跨平台方案今天不在我们的讨论范围内，他们确实有具备热更的能力，但我认为他们不够&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trick&lt;/code&gt;。时至今日，此类的跨平台框架基本已经被apple认可，因为他们已经是非常成熟的框架，风险也相对可控）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-6ee304457bcef8e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;执行流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来，我会拿两个有代表性的方案，进行一些技术细节的阐述。&lt;/p&gt;

&lt;h2 id=&quot;0x03-jspatch&quot;&gt;0x03. &lt;a href=&quot;https://github.com/bang590/JSPatch&quot;&gt;JSPatch&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;第一个例子拿&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;我觉得是毫无疑问的，国内目前最有影响力的框架我依然觉得是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;，作者也一直是我的偶像，blog的文章我也经常拜读。作者将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;这种现成的语言作为热更脚本，再加上平台提供的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JScontext&lt;/code&gt;能够快速地进行与native的通信。站在巨人的肩膀上决定了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;从开始就是一个轻量高性能的热更框架。下面来简单说说&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;的执行逻辑和原理。&lt;/p&gt;

&lt;h4 id=&quot;0x031jscontext&quot;&gt;0x031.JSContext&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;， 一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;执行环境的对象，在一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;对象创建时，会在其中内置一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSVirtualMachine(JS虚拟机)&lt;/code&gt;,你可以非常方便快速地在native执行一段JS或者进行两种语言的互通，在这之中你不需要依赖任何WebView（就像node.js一样提供一个node环境）。就像下面这样:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;n&quot;&gt;JSContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evaluateScript&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;var name = &apos;wbq&apos;; var age = &apos;18&apos;; function addFunc(value1, value2){ return value1 + value2};&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;JSValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;addFunc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callWithArguments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;323&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;对象默认是隔离的，也就是他们都是单独的环境，彼此之前不能传递信息，当然你也可以通过:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (instancetype)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine;&lt;/code&gt;来创建多个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;对象来共享一个虚拟机，这里不展开。&lt;/p&gt;

&lt;h4 id=&quot;0x032引擎启动&quot;&gt;0x032.引擎启动&lt;/h4&gt;

&lt;p&gt;引擎启动之后，框架会通过上述的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;执行一个叫作&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;的文件，这个文件是框架的重点之一，我把他归结为两个功能:1.收集并解析热更脚本的数据。2.将解析完的数据交还给Native处理。&lt;/p&gt;

&lt;h4 id=&quot;0x033解析脚本方法替换&quot;&gt;0x033.解析脚本/方法替换&lt;/h4&gt;

&lt;p&gt;拉取脚本我觉得没什么好说的，下面讲讲脚本解析，挑demo中最简单的一个例子来讲&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;UIViewController&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;defineClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;JPViewController&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;handleBtn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tableViewCtrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;UIViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;navigationController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pushViewController_animated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tableViewCtrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;这里为什么对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt;，是因为在下面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleBtn&lt;/code&gt;这个方法中使用了这个类，&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt;方法在当前全局中保存了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewContrller&lt;/code&gt;这个对象，防止在进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController.alloc().init()&lt;/code&gt;方法的链式调用中不会出现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewContrller is not defined&lt;/code&gt;的报错。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defineClass = function(declaration, properties, instMethods, clsMethods){...}&lt;/code&gt;方法传入的是类的声明，属性、实例方法、类方法。而例子中第二个参数传入是一个实例方法的map，是因为作者在其中发现第二个参数不是数组的情况下，就会把第二个参数当作实例方法往前提。之后会把解析完的脚本数据通过native早就准备好的方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_OC_defineClass&lt;/code&gt;，进行处理：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;_OC_defineClass&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classDeclaration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JSValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instanceMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JSValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defineClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classDeclaration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instanceMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;其实OC的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defineClass&lt;/code&gt;方法内部的细节很多，当然本质就是进行方法替换，作者先将将方法转发的方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&lt;/code&gt;进行了替换，再将热更脚本收集的方法全部挂到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;替换的方法转发方法&lt;/code&gt;上(第一次会有点饶，可以多看几遍源码)，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSInvocation&lt;/code&gt;对象包含所有的方法入参和方法签名，非常适合在这里进行方法的调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当然&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController.alloc().init()&lt;/code&gt;类似的语句是做不到直接调用的，因为js中压根没有这些方法，作者博客也有讲到，所以另辟蹊径。在这一步，&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;会通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;正则&lt;/code&gt;对热更脚本进行一轮胶水代码的添加，在解析阶段，上述这句话会变成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)()&lt;/code&gt;，这样通过一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__c&lt;/code&gt;的统一的胶水函数，就能非常方便地把诸如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;方法交还给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;native&lt;/code&gt;进行调用了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是大致的执行流程了，当前其中还有很多复杂的细节，比如返回值的处理，上面只是讲到无返回值类型最简单的一种。各种参数类型的处理，各种语法的处理比如block，结构体，用libffi处理C函数等等。&lt;/p&gt;

&lt;p&gt;前段时间，在重读源码的过程中，逮住了一只野生的bang大佬，问了几个细节问题，收到了解答也是非常的开心。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-13671612c5ec6ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x34-小结&quot;&gt;0x34 小结&lt;/h4&gt;

&lt;p&gt;总的来说&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;是一个非常优秀的热更框架，作者也是一步步精益求精，满足了广大开发者的各种诉求。思路和实现都非常值得阅读和学习，目前github还在维护的热更框架采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;作为脚本语言的基本都是学习了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;思路，例如这个&lt;a href=&quot;https://github.com/yangyangFeng/TTPatch&quot;&gt;TTPatch&lt;/a&gt;（真没看出啥大区别…）。当然此类的解决方案虽然还是有过审的可能，但是大家渐渐地开始不太敢用了，毕竟被下架付出的成本远远比线上bug的成本高多了，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;进行动态化太容易被机审扫到了。&lt;/p&gt;

&lt;h2 id=&quot;0x04mango&quot;&gt;0x04.&lt;a href=&quot;https://github.com/YPLiang19/Mango&quot;&gt;Mango&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;第二个为什么选这个框架呢，因为第一次看到这个框架的时候，还是比较眼前一亮的，这个框架就是我所说的自制语言和自制编译器/解释器的代表型框架。具体可以看作者原理与使用介绍&lt;a href=&quot;https://www.jianshu.com/p/7ae91a2daead&quot;&gt;MangoFix：iOS热修复另辟蹊径&lt;/a&gt;，总的来说，开发者可以使用一种以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.mg&lt;/code&gt;为后缀的脚本文件，文件内容类似OC的语法，所以可以很快上手，之后同样对脚本进行解析，不同于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;的方法转发，Mango是直接通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libffi&lt;/code&gt;进行了方法替换。在研究框架的过程中，我发现如此优秀的轮子，网上关于的源码阅读和解释的文章缺很少，所以今天我想特别来说说。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;![img](https://upload-images.jianshu.io/upload_images/1709476-16c9960a772355e4.png?imageMogr2/auto-orient/strip&lt;/td&gt;
      &lt;td&gt;imageView2/2/w/810/format/webp)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;原理部分，我照搬了作者的原图。接下来具体来说说技术的实现点。&lt;/p&gt;

&lt;h4 id=&quot;0x041lexyacc&quot;&gt;0x041.Lex&amp;amp;&amp;amp;Yacc&lt;/h4&gt;

&lt;p&gt;作者在脚本的解析中用到了该工具，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lex&amp;amp;&amp;amp;Yacc&lt;/code&gt;可以让你轻易的解析复杂的语言，当你需要读取一个配置文件时，或者你需要编写一个你自己使用的语言的编译器时，你不用手工写解析器，他可以直接帮你做到你想要的事。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lex&lt;/code&gt;负责词法的分析，将脚本切割成一个个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacc&lt;/code&gt;负责解析语法分析，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将token&lt;/code&gt;按照你写的规则生成抽象语法树。注意 Lex 和 Yacc 都是基于正则表达，后面讲到。&lt;/p&gt;

&lt;h4 id=&quot;0x042bnf&quot;&gt;0x042.BNF&lt;/h4&gt;

&lt;p&gt;什么是BNF？总的来说BNF是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一个描述语法规则的语言&lt;/code&gt;。具体可以我上一篇&lt;a href=&quot;https://www.jianshu.com/p/d2c2ea279053&quot;&gt;编译原理（1）&lt;/a&gt;简单地介绍了一下BNF，不是啥新东西，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Yacc&lt;/code&gt;同样可以通过BNF提取语法规则。&lt;/p&gt;

&lt;h4 id=&quot;0x043脚本解析&quot;&gt;0x043.脚本解析&lt;/h4&gt;

&lt;p&gt;掌握了以上几个知识点，去理解原理也就变得不那么难了，还是找一个最简单的例子来聊聊。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequentialStatementExample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面是一个mg文件，可以看到和OC非常像，但是又有一些不一样。可以看到，该脚本目的是改掉原始&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sequentialStatementExample&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;1.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lex&lt;/code&gt; 部分:首先通过正则把关键字匹配出来，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewController&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;1&quot;&lt;/code&gt;一个个切出来，就是上述的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;void&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VOID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//void关键字&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;class&quot;&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CLASS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//class关键字&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Za&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Za&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf_create_identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yytext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;yylval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_retained&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//标识符 例如ViewController、UIViewController&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COLON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//分号&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; {&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;    mf_open_string_literal_buf();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;    BEGIN STRING_LITERAL_STATE;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;} //第一次匹配到&apos;&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&apos;开始进入字符串收集状态&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STRING_LITERAL_STATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;mf_append_string_literal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yytext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//匹配换行符之外的任意字符,字符串进行拼接&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STRING_LITERAL_STATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; {&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	MFExpression *expression = mf_create_expression(MF_STRING_EXPRESSION);&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	expression.cstringValue = mf_end_string_literal();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	yylval.expression = (__bridge_retained void *)expression;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	BEGIN  INITIAL;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	return STRING_LITERAL;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;} //在字符串状态匹配到&apos;&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&apos;，意味字符串匹配结束，继续进入首字符匹配模式&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yylval&lt;/code&gt;其中保存着相关的信息，这个信息就是在词法分析文件中(lex)进行设置的，而在语法分析文件中(yacc)就直接采用了
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yytext&lt;/code&gt; 是指向所匹配的字符串的指针（以 NULL 结尾），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yytext[0]&lt;/code&gt;就是当前首字符，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yyleng &lt;/code&gt;是这个字符串的长度。&lt;/p&gt;

&lt;p&gt;2.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Yacc&lt;/code&gt;部分刚开始啃确实会有一点难理解，先来个简单的，如何匹配一个实例方法&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nl&quot;&gt;instance_method_definition:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annotation_if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SUB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type_specifier&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method_name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_statement&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFExpression&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotaionIfConditionExpr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MFExpression&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFTypeSpecifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returnTypeSpecifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MFTypeSpecifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFBlockBody&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MFBlockBody&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFMethodDefinition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodDefinition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf_create_method_definition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotaionIfConditionExpr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnTypeSpecifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
				&lt;span class=&quot;err&quot;&gt;$$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_retained&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodDefinition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;annotation_if 可以是empty，SUB = ‘-‘， LP = ‘{‘  ，type_specifier = ‘返回类型’ ，RP = ‘}’  ，method_name = ‘函数名’ ，block_statement = ‘函数体’ ，这样就可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instance_method_definition&lt;/code&gt;匹配出一个实例方法了。但真正能把上述这个简单的脚本匹配出来需要还经过层层匹配，我稍微总结了一下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;member_definition_list : member_definition | member_definition_list member_definition;

member_definition : property_definition | method_definition

method_definition : instance_method_definition | class_method_definition;
 
instance_method_definition : annotation_if &quot;-&quot; &quot;(&quot; type_specifier &quot;)&quot; method_name block_statement

type_specifier : void | BOOL | Class | id | ... 

block_statement : &quot;{&quot;  statement_list  &quot;}&quot;

statement_list : statement | statement_list statement

statement : declaration_statement | if_statement | switch_statement | for_statement | foreach_statement | while_statement | do_while_statement | break_statement | continue_statement | return_statement | expression_statement
			
expression_statement : expression &quot;;&quot;

expression : assign_expression

assign_expression : ternary_operator_expression | primary_expression assignment_operator ternary_operator_expression

ternary_operator_expression : logic_or_expression  | logic_or_expression &quot;?&quot; ternary_operator_expression &quot;:&quot; ternary_operator_expression |
logic_or_expression  &quot;?&quot; &quot;:&quot; ternary_operator_expression

logic_or_expression : logic_and_expression | logic_or_expression &quot;||&quot; logic_and_expression

logic_and_expression : equality_expression | logic_and_expression &quot;&amp;amp;&amp;amp;&quot; equality_expression

equality_expression : relational_expression | equality_expression &quot;==&quot; relational_expression | equality_expression &quot;!=&quot; relational_expression

relational_expression: additive_expression | relational_expression &quot;&amp;lt;&quot;| &quot;&amp;lt;=&quot; | &quot;&amp;gt;&quot; | &quot;&amp;gt;=&quot;  additive_expression

additive_expression : multiplication_expression | additive_expression &quot;+&quot; multiplication_expression | additive_expression &quot;-&quot; multiplication_expression

multiplication_expression : unary_expression | multiplication_expression &quot;*&quot; unary_expression

unary_expression : postfix_expression | &quot;!&quot; unary_expression | &quot;-&quot; unary_expression

postfix_expression : primary_expression | primary_expression &quot;++&quot; | primary_expression &quot;--&quot;

primary_expression : IDENTIFIER | &quot;&amp;amp;&quot; IDENTIFIER | primary_expression &quot;.&quot; IDENTIFIER | primary_expression &quot;.&quot; key_work_identifier | primary_expression &quot;.&quot; selector &quot;()&quot; ｜ primary_expression &quot;.&quot; selector &quot;(&quot; expression_list &quot;)&quot; 

|  primary_expression &quot;(&quot; &quot;)&quot; |  ...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就一个简单的实例方法需要经过这么多规则的筛选，不得不佩服作者细腻的逻辑能力，其实这之中也有非常多的细节，你要做很多二义性的判断，各种特殊情况的处理，我觉得这个工作量绝对是不小的。&lt;/p&gt;

&lt;p&gt;话说回来光匹配是不够的，在匹配过程中，还需要生成AST(抽象语法树)。比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$1、$2&lt;/code&gt;这类就是获取匹配出来的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yylval.expression&lt;/code&gt;，数字代表顺序代表匹配的token顺序，例如上述&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MFTypeSpecifier *returnTypeSpecifier = (__bridge_transfer MFTypeSpecifier *)$4;&lt;/code&gt;就是把第四个token，方法的返回类型，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returnTypeSpecifier&lt;/code&gt;接收。又比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$$&lt;/code&gt;就代表把收集的语义封装的对象继续向上传递。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PS:我自己有个疑问，yacc在层层向上匹配的过程中，如果发现自己匹配错了会怎么样呢？是回溯吗？，还是在匹配过程中，他已经已经知道自己要走哪条路了？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解析完之后，会得到一个个的AST的对象保存在内存中，比如方法对象就是保存在NSMutableDictionary当中。之后通过libffi进行方法替换。&lt;/p&gt;

&lt;h4 id=&quot;0x044方法执行&quot;&gt;0x044.方法执行&lt;/h4&gt;

&lt;p&gt;方法执行的逻辑也挺复杂，不断地计算AST的节点。各个语法树节点对象的类都需要具备类型（赋值、if语句、for循环、switch等等条件都会进到不一样的执行逻辑当中）和执行的表达式。eval方法将计算与以该节点为根的子树对应的语句、表达式及子表达式，并返回执行结果。一直执行，执行到根节点为止。作者在这一块可以说实现了一整个解释器/虚拟机。&lt;/p&gt;

&lt;h4 id=&quot;0x045小结&quot;&gt;0x045.小结&lt;/h4&gt;

&lt;p&gt;其实这个框架让我佩服的点是他完成了自制语言整个编译+解释的过程，虽不知道作者是何许人也，但是大佬的底层功力不可谓不深厚。尤其是编译原理，搞得相当的明白，我这种入门级小白只能顶礼膜拜。业界也有在大佬基础上进行更进一步探索的比如:&lt;a href=&quot;https://github.com/SilverFruity/OCRunner&quot;&gt;OCRunner&lt;/a&gt;，和该作者简单的聊了一下，作者本身只想做一个将OC语言翻译成mg文件的工具，最后干脆自己直接实现了从OC到AST的过程，我认为这个方向也很不错，毕竟开发者上手一门新的脚本语言，还是需要学习成本的。但是作者也表示，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lex&amp;amp;&amp;amp;Yacc&lt;/code&gt;来作为OC的翻译工具还是有很多坑，比如识别&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; ——&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSString *a 和 a * b&lt;/code&gt; 具有二义性的需要特殊处理， 也处理不了头文件的展开。作者最后说如果有机会可能会直接上clang，我：…………………..&lt;/p&gt;

&lt;h2 id=&quot;0x05总结&quot;&gt;0x05.总结&lt;/h2&gt;

&lt;p&gt;热更经过这么多年的发展，方案五花八门，但以上讲到的两种方案是最具代表性的，只要将热更做到安全可控，我相信热更还是有未来的，篇幅有限，先到这里。你知道的越多，你不知道的越多。&lt;/p&gt;

&lt;h2 id=&quot;0x06参考&quot;&gt;0x06.参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bang590&quot;&gt;bang590&lt;/a&gt;/&lt;a href=&quot;https://github.com/bang590/JSPatch&quot;&gt;JSPatch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/YPLiang19&quot;&gt;YPLiang19&lt;/a&gt;/&lt;a href=&quot;https://github.com/YPLiang19/Mango&quot;&gt;Mango&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Jun 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/06/21/%E8%81%8A%E8%81%8A%E7%83%AD%E6%9B%B4%E6%96%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/06/21/%E8%81%8A%E8%81%8A%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
        
        <category>热更新</category>
        
        
      </item>
    
      <item>
        <title>C++语法笔记</title>
        <description>&lt;p&gt;最近需要用C++做一些跨平台的组件，我自己本身对C++的语法不是特别熟练，也算是边写边学。
记录了一些平时开发过程中用到的语法笔记。&lt;/p&gt;

&lt;p&gt;1.C++支持函数重载，C不支持。底层用了namemangling技术，通过编译器把函数名字改掉，每个方法名不一样。不同编译器有不同的生成规则。&lt;/p&gt;

&lt;p&gt;2.extern “C”:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;被extern “C” 修饰的代码会按照C语言的方式去编译。&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;func()&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果函数同时有声明和实现，要让函数声明被extern “C” 修饰，函数的实现可以不修饰。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如有两个函数是通过.c（C语言）的方式进行实现的，那么在cpp的文件中，假如想使用这两个函数的话，不仅要声明，并且需要的在声明外要用 extern “C”  修饰。告诉编译器，这两个方法是用C语言来实现的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当然也可以这么写&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;cp&quot;&gt;#include &quot;math.h&quot;//include的作用:把math.h的内容原封不动的拷贝一份。
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么一个函数声明既要给C调用又要给C++调用怎么办呢？用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cplusplus&lt;/code&gt;宏来判断你是否在C++的环境&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;    
  &lt;span class=&quot;c1&quot;&gt;//这里是是你的声明或者代码,xxx&lt;/span&gt;
    
&lt;span class=&quot;cp&quot;&gt;#ifdef __cplusplus 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.防止重复include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基于include只是执行了copy操作，所以include多次在语法上都没啥问题，但是代码量会增多，因此为了防止多次include&lt;/p&gt;

    &lt;p&gt;可以用以下代码:首次未定义才进入声明逻辑。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#ifndef ABC
#define ABC
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;xxx&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;或者可以用编译器的特性&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; #pragma once &lt;/code&gt;来指名头文件只包含一次。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两者区别:第一种不受编译器的任何限制，是标准语法。第二种老编译器不支持，兼容性不够，只针对整个文件。&lt;/p&gt;

&lt;p&gt;4.inline内联函数:本质把方法替换成具体实现，可以减少函数调用的开销，会增大代码体积会。但inline只是仅仅是建议编译器进行替换，有时候声明了也不一定起作用，比如:递归。递归是无法内联的。&lt;/p&gt;

&lt;p&gt;内敛函数和宏都可以减少函数的开销，对比宏，内敛函数有函数的特性，有代码提示。&lt;/p&gt;

&lt;p&gt;5.const:被修饰的变量不可修改&lt;/p&gt;

&lt;p&gt;如果修饰的是类或者结构体，那么其中的成员也不可更改。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const修饰右边的东西&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//int * 是一个int指针 p是具体的值&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//修改p指向的具体值&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//修改p的值&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// p1是常量，*p1是常量，所以不能改年龄&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 和p1没区别&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//p3是常量，*p3不是，因此可以年龄。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//两个都不能改&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//两个都不能改&lt;/span&gt;
 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.引用&lt;/p&gt;

&lt;p&gt;在C++ 中，引用可以起到跟指针类似的功能，但指针可以修改，引用必须初始化，一旦指向了某个变量，就不可以再改变。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;refAge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;价值:比指针更安全。因为指针在中途可以修改指向，引用不能。&lt;/p&gt;

&lt;p&gt;本质:引用是弱化了的指针。本质是指针&lt;/p&gt;

&lt;p&gt;7.this&lt;/p&gt;

&lt;p&gt;通常一个对象的成员变量是在对象当中的，而函数是放在代码段的，为了在函数体内用this能访问到对象本身，这里有个一个隐式参数，把对象地址传入函数体中，然后将对象地址给this进行赋值&lt;/p&gt;

&lt;p&gt;8.堆的申请和释放&lt;/p&gt;

&lt;p&gt;new和delete或者new[]和delete[]必须成对出现&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//申请连续的4个字节、*p指向第一个。char类型的数组&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;11&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//给第一个字节赋值&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;12&quot;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//给第二个字节赋值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//p的4个字节每一个字节都是1&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.析构函数&lt;/p&gt;

&lt;p&gt;对象销毁时，进行调用，通过malloc分配的对象free时不会调用析构函数，声明为pulic才能被外界正常使用。&lt;/p&gt;

&lt;p&gt;构造方法的顺序和析构的顺序相反。&lt;/p&gt;

&lt;p&gt;构造函数: 父类构造-&amp;gt;子类构造&lt;/p&gt;

&lt;p&gt;析构函数: 子类析构-&amp;gt;父类析构&lt;/p&gt;

&lt;p&gt;10.多态&lt;/p&gt;

&lt;p&gt;定义:同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。&lt;/p&gt;

&lt;p&gt;方法的调用，默认看指针类型进行操作，不看实际的对象类型是什么。&lt;/p&gt;

&lt;p&gt;很多语言默认支持多态，C++要实现多态，需要用到虚函数。&lt;/p&gt;

&lt;p&gt;11.虚函数&lt;/p&gt;

&lt;p&gt;定义:被virtual修饰的成员函数&lt;/p&gt;

&lt;p&gt;只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（子类可以省略virtual关键字）&lt;/p&gt;

&lt;p&gt;1.有虚函数存在一个类顶部会多4个字节，这个4个字节存放的是虚表（虚函数表）的地址，虚表里面有每个虚函数的方法地址。&lt;/p&gt;

&lt;p&gt;2.所有对象共用一张虚表。（如果是多继承就多张虚表）&lt;/p&gt;

&lt;p&gt;3.因此如果父类指针指向子类对象，析构函数也应该定义为虚函数。否则释放时无法调用子类的虚函数。&lt;/p&gt;

&lt;p&gt;12.模版&lt;/p&gt;

&lt;p&gt;模版的本质类似范型，编译器会为多类型的入参生成多个类型的函数。&lt;/p&gt;

&lt;p&gt;13.类型转换&lt;/p&gt;

&lt;p&gt;static_cast:普通转换，不支持交叉转换。&lt;/p&gt;

&lt;p&gt;dynamic_cast:支持交叉转换，会做安全计算。&lt;/p&gt;

&lt;p&gt;reinterpret_cast:简简单单的二进制复制。&lt;/p&gt;

&lt;p&gt;const_cast:把const转换成非const。&lt;/p&gt;

&lt;p&gt;14.nullptr可以解决NULL的二义性（既代表0又代表空指针）&lt;/p&gt;

&lt;p&gt;15.智能指针&lt;/p&gt;

&lt;p&gt;传统指针存在的问题:&lt;/p&gt;

&lt;p&gt;1.需要手动管理内存。&lt;/p&gt;

&lt;p&gt;2.容易发生内存泄漏。&lt;/p&gt;

&lt;p&gt;3.释放之后产生野指针。&lt;/p&gt;

&lt;p&gt;智能指针可以解决这些问题。&lt;/p&gt;

&lt;p&gt;实现原理类似于装箱和拆箱，用一个内部私有指针保存对象。在释放时，自动释放私有的内部指针。&lt;/p&gt;

</description>
        <pubDate>Wed, 09 Jun 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/06/09/CPP%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/06/09/CPP%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</guid>
        
        <category>C++</category>
        
        
      </item>
    
      <item>
        <title>编译原理（一）</title>
        <description>&lt;p&gt;最近在看基于DSL的热更新框架，瞬间对编译器原理产生了浓厚的兴趣。百度、知乎了很久，给自己定了一套学习路径(🐶)。龙书，虎书，鲸书这些是必看的，但是书还在路上。《Engineering a Compiler》和《游戏脚本高级编程》看起来口碑也不错。不过我的入门，从一本叫《两周自制脚本语言》开始（以下简称《两周》）。希望这个主题会有第二篇、第三篇….吧。&lt;/p&gt;

&lt;h2 id=&quot;0x01前言&quot;&gt;0x01.前言&lt;/h2&gt;

&lt;p&gt;在计算机的世界里，计算机的底层执行逻辑一定是通过二进制的命令结合硬件电路实现的。硬件看不懂我们的代码，它们只知道把高电压当成1，低电压当成0，执行过程就是一次次放电过程。所以程序本质上是一串很长很长的的二进制数字，由于不易阅读，人们常通过汇编语言程序来表达这个巨大的数字。程序只有载入内存后才能通过硬件执行。因此，用户在实际使用的时候，必须先通过软件从磁盘文件中读取机器语言程序，再将复制到内存中，这类程序称不上时语言处理器，通常称为操作系统。&lt;/p&gt;

&lt;p&gt;而计算机是如何将高级语言变成机器语言的呢？这里就需要用到语言处理器，其实语言处理器在我们的工作中时时刻刻都在接触。这之中大致分两种:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编译器：将某种语言写成的程序转换成另一种语言的程序。通常会将源程序转化为机器语言程序。编译器转化程序的行为称为编译。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解释器：根据程序中的算法执行运算。简单来讲，它时一种用于执行程序的软件。如果执行的程序由虚拟机器语言或类似于机器语言的程序设计语言写成，这种软件也能称为虚拟机，例如JS，Python等脚本语言。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java语言会特殊一些，首先会通过编译器把源代码转化成Java字节码，并将这种虚拟的机器语言保存在文件中。之后,Java虚拟机的解释器将执行这些代码。大多数Java虚拟机为了提高性能，会在执行过程中通过编译器将一部分Java字节码直接转化为机器代码使用，执行过程中进行搞得机器语言转化称为动态编译或JIT编译，转化后得到的机器语言将被载入内存，由硬件执行，无需使用解释器。&lt;/p&gt;

&lt;p&gt;过去人们提到编译器时，首先会联想编译过程非常耗时。不过由于编译后实际执行的是机器语言，因此执行速度很快。而对于解释器，人们通常认为它会在程序输入的同时立即执行，执行速度较慢。这就是两者的基本区别。现代的解释器内部常采用各种类型的编译器，已经越来越没必要将解释器与编译器区分看待。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-dd506a10bd81b27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;编译的大致过程&quot; title=&quot;编译的大致过程&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;0x02词法分析&quot;&gt;0x02.词法分析&lt;/h2&gt;

&lt;p&gt;语言处理器的第一个组成部分是词法分析。程序的源代码本质只是一长串字符串，这样的字符串很难处理，语言处理器通常会首先将字符串中的字符以单词为单位分组，切割成多个子字符串。这就是词法分析&lt;/p&gt;

&lt;h3 id=&quot;token对象&quot;&gt;token对象&lt;/h3&gt;

&lt;p&gt;下面是某个程序中的一行代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;while i &amp;lt; 10 {
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;词法分析会把它拆分为下面这样的字符串&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&quot;while&quot; &quot;i&quot; &quot;&amp;lt;&quot; &quot;10&quot; &quot;{&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这句代码被分割为了5个字符串。通常把词法分析的结果称为单词（token），当然可能你的换行会变成一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;\n&quot;&lt;/code&gt;的token，注释标志也可能会变成一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/*&quot;&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;*/&quot;&lt;/code&gt; 两个token，这都是有可能的，具体看编译器是如何工作的。当然具体是怎么切的，《两周》这本书用的是正则匹配:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0-9]+&lt;/code&gt;来匹配整型。&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[A-Z_a-z][A-Z_a-z0-9]*&lt;/code&gt;(以字母、下划线开头，之后仅包含有字母、数字、下划线)来匹配标识符，（是不是很像我们平时定义变量?，不可以用数字开头）&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;执行词法分析时，语言处理器会逐行读取源代码，从各行开头起检查内容是否与该正则表达式匹配，并在检查完后获取与正则表达式括号内的模式相匹配的字符串。&lt;/p&gt;

&lt;p&gt;在这一步中，空格、换行、注释这些都会被分析器所忽略。编译器会事先获知之后取得的单词，一边获取一边构造抽象语法树，在中途发现构造有误时，需要退回若干单词，重新构造语法树，称之为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;回溯&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;0x03语法分析ast抽象语法树&quot;&gt;0x03.语法分析/AST(抽象语法树)&lt;/h2&gt;

&lt;p&gt;语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树。抽象语法树（AST，Abstract Syntax Tree）是一种用于表示程序结构的树形结构。语法分析的主要任务是分析单词之间的关系，如判断哪些单词属于同一个表达式或语句，以及处理左右括号（单词）的配对等问题。这一阶段还会检查程序中是否含有语法错误。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;13 + x * 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们对上面这条语句进行词法分析。我们通过上面的分析可以得出，编译器大致会分割成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;13&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; +&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; x&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; *&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;，这几个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后我们将这些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;进行重新排列，变成一个抽象语法树，每个叶节点存储着具体的值和值的类型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-60b4d19edf3a6cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;，在进行语法树构建的过程中，符号其实是有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;优先级&lt;/code&gt;以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;左右结合顺序&lt;/code&gt;的，后面会提到。&lt;/p&gt;

&lt;h2 id=&quot;0x04bnf&quot;&gt;0x04.BNF&lt;/h2&gt;

&lt;p&gt;什么是BNF？总的来说BNF是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一个描述语法规则的语言&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;初次理解BNF会觉得很难懂，至少我是理解了好久。如果看文字实在太绕，建议看视频，https://www.bilibili.com/video/BV1Us411h72K?from=search&amp;amp;seid=14895223797156770591 我是看了这个视频之后开窍了（我居然可以在bilibli学技术）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BNF中常用的元字符及其表示的意义如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;在双引号中的字 &quot;word&quot; 代表着这些字符本身。而double_quote用来代表双引号；
在双引号外的字（有可能有下划线）代表着语法部分；
尖括号 &amp;lt; &amp;gt; 内包含的为必选项；
方括号 [ ] 内包含的为可选项；
大括号 { } 内包含的为可重复0至无数次的项；
圆括号 ( ) 内包含的所有项为一组，用来控制表达式的优先级；
竖线 | 表示在其左右两边任选一项，相当于&quot;OR&quot;的意思；
::= 是“被定义为”的意思；
...  表示术语符号；
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;理解了上面这些符号的规则，可以来看看书中对自制语言的规则描述:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;primary ::=  &quot;(&quot; expr &quot;)&quot; | NUMBER | IDENTIFIER | STRING
factor ::=  &quot;-&quot; primary | primary
expr ::= factor { OP factor }
block ::=  &quot;{&quot; [ statement ] { (&quot;;&quot; | EOL) [ statement ]} &quot;}&quot;
simple ::=  expr
statement ::= &quot;if&quot; expr block [ &quot;else&quot; block ] | &quot;while&quot; expr block | simple
program ::=  [ statement ] (&quot;;&quot; | EOL)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;非终结符factor（因子）或表示一个primary，或表示primary之前再添加一个-号的组合&lt;/p&gt;

&lt;p&gt;expr（表达式）用于表示两个factor之间夹有一个双目运算符的组合&lt;/p&gt;

&lt;p&gt;block（代码块）指的是由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;括起来的statement（语句）序列&lt;/p&gt;

&lt;p&gt;statement之间需要用分号或换行符（EOL）分隔。由于Stone 语言支持空语句，因此规则中的statement两侧写有中括号[]。可以看到，它的结构大致与expr类似。它们都由其他的非终结符（statement或factor）与一些用于分隔的符号组合而成&lt;/p&gt;

&lt;p&gt;statement可以是if语句、while语句或仅仅是简单表达式语句（simp1e）。简单表达式语句是仅由表达式（expr）构成的语句。&lt;/p&gt;

&lt;p&gt;最后的program（程序）是一个非终结符，它可以包含分号或换行符，用于表示一句完整的语句。其中，statement可以省略，因此program还能用来表示空行。代码块中最后一句能够省略句尾分号与换行符。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;想要彻底理解BNF，递归的思想是必不可少的&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;假如以上BNF规定了语言语法的时候，在进行抽象语法树组合的时候，如果不符合以上制定的这些规则时，编译器就会抛出异常。&lt;/p&gt;

&lt;p&gt;例如:最后声明的program（程序），你只能用分号或者换行符作为结束符，你想用用句号（。）作为结束符，是不被允许的。&lt;/p&gt;

&lt;h2 id=&quot;0x04解释器执行&quot;&gt;0x04.解释器执行&lt;/h2&gt;

&lt;p&gt;语法分析将从词法分析器逐一读取非终结符program。即，以语句为单位读取单词，并进行语法分析，执行语法分析后得到的抽象语法树。只要通过语法分析得到抽象语法树，剩下的就简单了，只要从根结点开始遍历至叶节点，并计算各节点的内容即可，这就是解释器的基本实现原理。&lt;/p&gt;

&lt;p&gt;要根据得到的抽象语法树来执行程序，各个语法树节点对象的类都需要具备eval方法。eval是evaluate（求值）的缩写。eval方法将计算与以该节点为根的子树对应的语句、表达式及子表达式，并返回执行结果。一直执行，执行到根节点为止。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-4b57eb08639b8933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;看虚线方向就是执行方向&quot; title=&quot;看虚线方向就是执行方向&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;其实这同样是一种递归过程&lt;/code&gt;，&lt;/p&gt;

&lt;h2 id=&quot;0x05编译器&quot;&gt;0x05.编译器&lt;/h2&gt;

&lt;p&gt;在使用中间代码解释器时，我们要事先将抽象语法树转换为中间代码。简单来说，中间代码是一种虚拟的机器语言，因此，中间代码的转换方法，其实与编译器将抽象语法树转换为真正的机器语言时采用的方法大体相同。&lt;/p&gt;

&lt;h4 id=&quot;中间代码与机器语言&quot;&gt;中间代码与机器语言&lt;/h4&gt;

&lt;p&gt;之间利用抽象语法树，语言处理器需要在节点之间往返操作，这是一件费时的工作。因此，如果语言处理器能够实现计算遍历顺序，并以此重新排列节点，执行开销就可能有所降低&lt;/p&gt;

&lt;p&gt;通常，语言处理器不会直接将重新排列的抽象语法树节点作为中间代码使用。如果直接保存抽象语法树的节点，多余的无用信息是一种空间上的浪费，因此，我们需要设计一种虚拟的机器语言，并将各个节点转换为与该节点运算逻辑对应的机器语言。大多数语言处理器使用的中间语言都是这种转换后的代码（见下图）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-b409299e7b66b062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虚拟机由若干个通用寄存器与内存组成。内存分为四个区域，分别是栈（stack）区、堆（heap）区、程序代码区与文字常量区。虚拟机器语言保存于程序代码区，字符串字面量保存干文字常量区。&lt;/p&gt;

&lt;p&gt;本书作者自己实现了一个自制的虚拟机，在程序启动过程中同时启动虚拟机，对于抽象语法树的操作不再是简单的执行，而是首先将语言转为虚拟机语言，再通过汇编执行函数的思路进行执行。不过本书中的程序为了演示虚拟机的工作原理并没有给程序性能带来提升，因为自制的语言是程序启动过程中进行编译，执行。不如直接执行抽象语法树来的直接。&lt;/p&gt;

&lt;h2 id=&quot;0x06总结&quot;&gt;0x06.总结&lt;/h2&gt;

&lt;p&gt;其实书中的细节还有很多，作者对自制的语言也加入很多功能，比如函数，静态变量、闭包等等。在实现局部和全部变量时，居然讨巧的用了一个hashmap + namespace来实现，来确保变量的作用域，这真的非常有意思。&lt;/p&gt;

&lt;p&gt;看了这本书，算是对编译原理有一个入门级的认识吧， 取名（1），希望鞭策自己这个主题会有第二篇、第三篇….吧。&lt;/p&gt;

&lt;p&gt;众所周知，目前程序的编译器基本都是C++实现的，但是第一个C++程序又是谁给编译的呢？都知道蛋是鸡生的，那么第一只鸡是哪来的呢？&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;所谓C语言编译器，就是把编程得到的文件，比方.c,.h的文件，进行读取，并对内容进行剖析，按照C语言的规则，将其转换成体系能够履行的二进制文件。
其本质在于对文件的读入，剖析，及处理。这些操作，C言语都是能够完成的。所以用C言语来做C言语的编译器是彻底可行的。
可是，历史上的第一个C言语编译器，必定不是C言语写的，因为在没有编译器时，无法把C言语转换成可履行文件。
只需有了第一版其它言语的编译器，就能够用C言语写编译器了。事实上，现在大多数的C言语编译器，都是用C言语写的。
首要你要理解编译的意思，它是指把高档言语翻译成计算机 能读懂的低级言语（二进制代码），这样计算机才会履行你 的指令，
编译器就相当于一个翻译，在翻译的过程中还会检 查你语法上有没有错误 C言语编译器自然是把用C言语写的程序翻译成二进制代码咯。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;0x07参考&quot;&gt;0x07.参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Bm5n8qovMrRMxE0MRZMGKw&quot;&gt;两周自制脚本语言&lt;/a&gt;/提取码: t8qm&lt;/p&gt;

&lt;p&gt;https://github.com/wmathor/Stone-language&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/30023409&quot;&gt;世界上第一个编译器是怎么来的？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Us411h72K?from=search&amp;amp;seid=14895223797156770591&quot;&gt;编程范式02BNF&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 09 May 2021 14:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%80/</guid>
        
        <category>编译原理</category>
        
        
      </item>
    
      <item>
        <title>第一篇博客</title>
        <description>&lt;p&gt;用jekyll定制自己的blog，无需服务器，无需数据库 😂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-code&quot;&gt;~ $ gem install jekyll

~ $ jekyll new my-awesome-site

~ $ cd my-awesome-site

~/my-awesome-site $ bundle exec jekyll serve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开 http://localhost:4000，就可以看到默认模版了，最后用GitHub Pages部署即可，祝大家玩得开心。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Aug 2018 08:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/21/firstblog/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/21/firstblog/</guid>
        
        
      </item>
    
  </channel>
</rss>
