<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wbq&apos;s Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 15 Nov 2021 09:51:03 +0800</pubDate>
    <lastBuildDate>Mon, 15 Nov 2021 09:51:03 +0800</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>浅谈区块链（一）</title>
        <description>&lt;p&gt;这篇文章本来是发在简书，发出去的一刻，直接被锁，只能自己可见，估计是文章关键字扫到了，看来目前国内对这个管控还是挺严。
话说很早就开始玩币了，从17年开始，从来没有赚过钱，当时是在网上冲浪发现这个东西，下了个火币来玩一玩，买了500块eos，事实证明eos到现在还是那个鸟样。这几天心血来潮，想要系统性地学习一下区块链的知识，再好好去研究一下别的项目，区块链的知识量真的是太大了，先总结第一篇，方便自己后续回顾。&lt;/p&gt;

&lt;h3 id=&quot;比特币的交易挖矿原理&quot;&gt;比特币的交易、挖矿原理&lt;/h3&gt;

&lt;p&gt;现实生活中当A给B转钱的时候，一定会产生一条记录，不管任何的金融系统都需要记录这一条记录。但众所周知虚拟货币的第一大亮点就是去中心化，什么是去中心化？&lt;/p&gt;

&lt;p&gt;在支付宝中A给B转钱，支付宝的系统会负责完成这一笔交易并且记录这一条记录，这就是中心化，中心化的特点就是A跟B的交易需要支付宝这个第三方来介入，否则这比交易将无法完成。银行转账一样的道理。&lt;/p&gt;

&lt;p&gt;那么比特币是如何完成这一笔交易的，并且记账的呢？&lt;/p&gt;

&lt;p&gt;这里先引出一个概念，比特币客户端本质上来说是一个应用，跑在计算机上的应用，类似于在centOS上起了一个JavaWeb程序，目前世界上有上百万台计算机运行着这个应用，就是我们俗称的矿机。&lt;/p&gt;

&lt;p&gt;当A通过比特币客户端（钱包，轻应用）给B转钱，客户端会广播这条信息到全网的比特币客户端，所有的节点一起来记账，把这条记录先记录到自己的内存中，每台计算机都会把最近一段时间收到的交易进行打包形成一个区块，拼到上一次打包的区块上，类似于链表结构，形成了一个区块链。&lt;/p&gt;

&lt;p&gt;1.因为记账只有唯一一台机器可以记这几分钟的账，第一个问题，那么多节点同时计算，谁说了算？&lt;/p&gt;

&lt;p&gt;打包的过程是将 最近有效的交易 + 时间戳 + 随机数 通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sha256&lt;/code&gt;计算出一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashcode&lt;/code&gt;，当这个值符合前几位为0的时候，这台机器就有资格进行打包，把最近这些交易进行打包记账，那么相应的，系统会给予奖励，这个奖励是打包过程中，节点自动同时会把这笔交易加入到计算当中，这就是挖矿。系统会动态地调整计算难度，确保在10分钟左右出一个块，截止到目前是必须符合前19个是0。&lt;/p&gt;

&lt;p&gt;2.这么多机器，一台客户端广播得过来吗？&lt;/p&gt;

&lt;p&gt;据不完全统计目前的全网节点只需要12秒就可以同步90%的节点，广播的效率相比于打包的过程还是相当快的，相比与真正耗时的是计算那个hashcode。而且不需要全节点广播，只需要广播就近几个节点，通过传递很快可以广播到全网。&lt;/p&gt;

&lt;p&gt;3.关于余额的计算&lt;/p&gt;

&lt;p&gt;在比特币的网络中没有余额的概念，而是通过纯计算得出。假如我想知道某个钱包的余额，只需要计算在链条上所有关该钱包的收款记录就能动态计算出我目前的余额了。每条交易的模型在BTC中称为UTXO。有一个输入一个输出。每个UTXO中输入方是花费方，输出方是消费方，每一个输出都犹如现实中的一张纸币，他只有两种状态，属于你或者不属于你。未花费就是该张纸币属于你，已花费就是该张纸币不属于你。每一个 UTXO 和纸币一样，只可能有两种状态，要么是没有被花费的，要么就是已经被花费，所有权变成了其他人或者地址，成为其他地址的 UTXO。如果A有10个BTC，转给B10个，那么就是一个UTXO。如果转5个那么就是两个UTXO，因为存在找零操作。一个UTXO是A-&amp;gt;B 5个BTC ，一个是UTXO是A-&amp;gt;A 5个BTC .&lt;/p&gt;

&lt;p&gt;4.为什么说不可篡改&lt;/p&gt;

&lt;p&gt;这就是公有链的价值所在，假设说中心化的金融系统是可以随意篡改的话，那么去中心化的区块链相对来说是非常安全的。首先在中心化的系统中，改一条数据神不知鬼不觉，参考蚂蚁的员工把自己的余额后面加了两个0。在区块链中，每个区块的整个所有的信息都会有个hashcode。每个块都会保存前一个块的hashcode。又因为记账是大家一起记，假设你在你的节点把其中几个块改了，庞大的系统是不认可你的，因为剩下99.9999…%的节点记是正确的数据，只有你一个是错误，你这条链是不会有人继续往下写的，这就是共识的力量。在公有链中，除非你有绝对的实力可以改掉一半以上的机器数据，当然能做到这一点的人也不屑于做修改数据来增加自己的财富。&lt;/p&gt;

&lt;p&gt;5.BTC的劣势&lt;/p&gt;

&lt;p&gt;一.因为由于系统设计的问题，导致BTC的交易TPS相当慢，一秒钟只能发起7笔左右的交易，这在当今这个高速的互联网是根本无法满足需求的。&lt;/p&gt;

&lt;p&gt;二.由于BTC挖矿的机制是POW，所以就造成了电力和资源的浪费，多个矿池都在做同样一件事，而真正生产的价值的只有那么几台。&lt;/p&gt;

&lt;h3 id=&quot;关于交易所&quot;&gt;关于交易所&lt;/h3&gt;

&lt;p&gt;交易所本质是一个中心化的系统，他只有唯一一个钱包地址。所以其实在里面所有的交易，都是基于他自己的数据库，你的挂单，你的买币其实都是他数据库里的加加减减。这也就是解释了，为什么BTC这么慢的TPS，在交易所每秒却有成百上千的挂单成交。&lt;/p&gt;

&lt;p&gt;因为每个钱包余额都是透明的，所以你可以看到头部的钱包基本都是交易所的钱包。&lt;/p&gt;

&lt;p&gt;交易所其实是个很坑的东西，首先挂单交易都需要手续费，你划转到钱包需要手续费。而且你在交易所的币实际上都在他的钱包里，理论上他可以拿你的钱做任何的事。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;系统地了解完BTC的整个机制之后，感叹这确实不像十多年前设计的东西，思路真的太超前了，当我们还在拼命寻求一个公平公开透明的中心化机制的时候，设计者已经开创了一个这样的自由公开透明的国度。虽然我觉得设计者在设计之初一定没想到在十几年后的今年，BTC会对世界产生这么大的影响。现如今在加密货币的世界中，所有的项目都是在此基础之上进行搭建改造的。这真是一门另人着迷的技术啊。&lt;/p&gt;

</description>
        <pubDate>Thu, 11 Nov 2021 14:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/11/11/%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/11/11/%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE-%E4%B8%80/</guid>
        
        <category>Blockchain</category>
        
        
      </item>
    
      <item>
        <title>Xcode13.0 iOS15 debug异常崩溃</title>
        <description>&lt;p&gt;早上应用各种崩溃，一个应用WKWebiew莫名崩溃、另一个则是起都起不来。只要不是处于调试模式下都OK，即便是从模拟器点开app。分析了半天还是同事告知是苹果出了问题….&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes/&quot;&gt;iOS &amp;amp; iPadOS 15 Release Notes&lt;/a&gt;
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-e58ca44985dd5d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;临时解决办法&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Workaround: In Xcode, select Product &amp;gt; Scheme &amp;gt; Edit Scheme, 
then deselect Run &amp;gt; Options &amp;gt; Queue Debugging &amp;gt; “Enable backtrace recording.”
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;先这么的，乖乖等13.1吧 - - 。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/10/12/xcodebug/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/10/12/xcodebug/</guid>
        
        <category>Xcode</category>
        
        
      </item>
    
      <item>
        <title>如何设计一个好的WebView容器</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;众所周知，iOS的网页组件很封闭，基本就是基于WKWebview修修改改。看起来能做的不多，但是一个好的webview容器，其实能做的事情还有很多。今天想聊一下，一个好的webview的容器，除了自己本身的功能，还需要哪些设计。&lt;/p&gt;

&lt;h3 id=&quot;1jsbridge的设计&quot;&gt;1.jsbridge的设计&lt;/h3&gt;

&lt;p&gt;wk很容易就可以使用jsbridge，只要在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configuration.userContentController&lt;/code&gt;注入调用名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (void)addScriptMessageHandler:(id &amp;lt;WKScriptMessageHandler&amp;gt;)scriptMessageHandler name:(NSString *)name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js中附上刚面的name就可以调用了，非常方便&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;window.webkit.messageHandlers.name.postMessage()
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时也可以在想要的时间点（一般在初始过程）注入JS。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;
[userContentController addUserScript:[[WKUserScript alloc] initWithSource:script
																		injectionTime:WKUserScriptInjectionTimeAtDocumentStart
																	 forMainFrameOnly:YES]];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;健全的容器，需要健全的bridge方法，比如容器的版本，基础的设备信息等等。业务功能比如照片选择器、图片浏览器、原生扫码页、蓝牙等等，都可以按需加入。当然光提供bridge，几个还好，一旦多起来，他们就需要体系，接收方法需要统一入口，交由容器解析，有一套健全的派发逻辑，因为native的方法代码可能散落在工程各处。返回结果需要统一出口，由容器统一格式返回。&lt;/p&gt;

&lt;p&gt;而在js端调用的过程中需要规范调用的格式，入参的规则，成功和失败的回调规则。当native执行完毕之后，需要告知js侧结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-b6d429e033c16206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image-20210903110547976.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2同层渲染&quot;&gt;2.同层渲染&lt;/h3&gt;

&lt;p&gt;让网页拥有原生组件的能力，这是近两年比较火的同层渲染技术。&lt;/p&gt;

&lt;p&gt;市面上的实现原理也已经比较成熟，具体实现可以看微信这篇&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813&quot;&gt;小程序同层渲染原理剖析&lt;/a&gt;写的非常详细。&lt;/p&gt;

&lt;p&gt;github上也有相关的源码级别实现。iOS的做法来说相对来说“trick”一些，而android在实现上会更加复杂一点。&lt;/p&gt;

&lt;h3 id=&quot;3离线加载&quot;&gt;3.离线加载&lt;/h3&gt;

&lt;p&gt;故名思议通过加载本地的资源进行网页的渲染，达到网页秒开的效果。&lt;/p&gt;

&lt;p&gt;在这其中，资源的动态的下发是比较重要的一环，下发的时间点，如何正确的命中用户都是需要做的课题。后续数据的追溯，命中情况等都需要监控。&lt;/p&gt;

&lt;p&gt;当然，资源的管理是一方面，如果正确识别需要加载的URL绕过网络去加载本地的资源的这个过程同样需要精细化设计。WKWebView的请求拦截，网上基本说烂了，这篇文章基本是结贴&lt;a href=&quot;https://juejin.cn/post/6922625242796032007&quot;&gt;WKWebView 请求拦截探索与实践&lt;/a&gt;。市面上思路都差不多，”WKWebView不支持http、https拦截”、”Body丢失”、”Cookie同步”这些问题只要花时间都是有解的。&lt;/p&gt;

&lt;p&gt;补充：关于body丢失的问题，不管是用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSURLProtocol&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WKURLSchemeHandler&lt;/code&gt;，基本都是需要js端配合hook &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XMLHTTPRequest&lt;/code&gt;，只需在容器启动从native注入hook的js，对前端同学同样也是透明的，没有负担。&lt;/p&gt;

&lt;h3 id=&quot;4性能稳定监控&quot;&gt;4.性能稳定监控&lt;/h3&gt;

&lt;p&gt;基本的性能监控不能少，统计网页从打开到显示的时间，网页加载完毕时候统计是否是白屏等等。&lt;/p&gt;

&lt;p&gt;也可以通过一些网页的属性传给网页进行统计比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;window.performance&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;补充：白屏的几种判别方法:1.截图像素点的判断。2.遍历dom节点查看是否有正常子节点。&lt;/p&gt;

&lt;h3 id=&quot;5预热&quot;&gt;5.预热&lt;/h3&gt;

&lt;p&gt;今日头条的详情页部分是通过WKWebView进行渲染的，好的用户体验的一个很重要的点就是wk的预热和复用，详见参考中的链接。&lt;/p&gt;

&lt;h3 id=&quot;6其他&quot;&gt;6.其他&lt;/h3&gt;

&lt;p&gt;大的块暂时能想到的就这么多，剩下的定制化功能其实还有很多，开发者可以不断地往上垒，治理好bridge是关键，比如容器可以支持查看js日志，并且在线调试，增加一些对navibar，navibaritem，横屏，手势等进行设置的功能，又比如将网页一些耗时任务交给native处理，在体验上也会有不错的效果。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;相比于flutter，我其实更崇尚基于native + h5的这种hybrid开发，随着h5的体验越来越好，其实这种开发方式已经是目前主流的开发模式了，不管是从效率、易用、容错等方面都是一个相当不错的选择。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Xqr6rQBbx7XPoBESEFuXJw&quot;&gt;今日头条品质优化 - 图文详情页秒开实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813&quot;&gt;小程序同层渲染原理剖析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6922625242796032007&quot;&gt;WKWebView 请求拦截探索与实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Naituw/WBWebViewConsole&quot;&gt;WBWebViewConsole&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/06/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84webview%E5%AE%B9%E5%99%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/06/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84webview%E5%AE%B9%E5%99%A8/</guid>
        
        <category>WKWebView</category>
        
        
      </item>
    
      <item>
        <title>聊聊热更新</title>
        <description>&lt;p&gt;想写这篇文章挺久了，今天我们来聊一聊热更新。&lt;/p&gt;

&lt;h2 id=&quot;0x01前言&quot;&gt;0x01.前言&lt;/h2&gt;

&lt;p&gt;国内开发者对于热更新不可谓不热衷，前仆后继地发明一个又一个新思路，我自己也是对热更新特别感兴趣，尤其对iOS来说，这更是一片敏感的灰色地带，自从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jspatch&lt;/code&gt;被苹果警告之后，各家公司的热更需求依然没有减弱，因此这个话题变得相当微妙，各家公司都有一些自己的方案，并且不再开源，因为开源意味着会像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jspatch&lt;/code&gt;一样变成把子，业界最著名的&lt;a href=&quot;https://github.com/DynamicCocoa/DynamicCocoa&quot;&gt;DynamicCocoa&lt;/a&gt;就是一个非常典型的例子，时至今日，再去打开这个仓库的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;issue&lt;/code&gt;依然会让你捧腹大笑。&lt;/p&gt;

&lt;h2 id=&quot;0x02演进过程&quot;&gt;0x02.演进过程&lt;/h2&gt;

&lt;p&gt;其实一路走来我对热更新演进过程的总结就是两个字 —— &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;内卷&lt;/code&gt;，虽然这两个戏谑的字不是那么合适，但事实就是如此，热更的方案变得更加多元化，防审核能力也变得更强。开发大佬们也已经不再局限于现成的脚本语言，转而自己去开发新的脚本语言。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-faa88b51c33c7d02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;演进过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;众所周知一个apple应用是静态编译成二进制文件的(AOT)，在线上去修改此类文件是不现实的，因此就需要用到脚本语言（JIT）+  动态化语言的能力，这就是热更的本质。几乎所有热更的流程基本都符合下面这张流程图的逻辑（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactNative &lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Weex&lt;/code&gt;等跨平台方案今天不在我们的讨论范围内，他们确实有具备热更的能力，但我认为他们不够&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trick&lt;/code&gt;。时至今日，此类的跨平台框架基本已经被apple认可，因为他们已经是非常成熟的框架，风险也相对可控）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-6ee304457bcef8e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;执行流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来，我会拿两个有代表性的方案，进行一些技术细节的阐述。&lt;/p&gt;

&lt;h2 id=&quot;0x03-jspatch&quot;&gt;0x03. &lt;a href=&quot;https://github.com/bang590/JSPatch&quot;&gt;JSPatch&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;第一个例子拿&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;我觉得是毫无疑问的，国内目前最有影响力的框架我依然觉得是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;，作者也一直是我的偶像，blog的文章我也经常拜读。作者将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;这种现成的语言作为热更脚本，再加上平台提供的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JScontext&lt;/code&gt;能够快速地进行与native的通信。站在巨人的肩膀上决定了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;从开始就是一个轻量高性能的热更框架。下面来简单说说&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;的执行逻辑和原理。&lt;/p&gt;

&lt;h4 id=&quot;0x031jscontext&quot;&gt;0x031.JSContext&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;， 一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;执行环境的对象，在一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;对象创建时，会在其中内置一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSVirtualMachine(JS虚拟机)&lt;/code&gt;,你可以非常方便快速地在native执行一段JS或者进行两种语言的互通，在这之中你不需要依赖任何WebView（就像node.js一样提供一个node环境）。就像下面这样:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;n&quot;&gt;JSContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evaluateScript&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;var name = &apos;wbq&apos;; var age = &apos;18&apos;; function addFunc(value1, value2){ return value1 + value2};&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;JSValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;addFunc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callWithArguments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;323&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;对象默认是隔离的，也就是他们都是单独的环境，彼此之前不能传递信息，当然你也可以通过:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (instancetype)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine;&lt;/code&gt;来创建多个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;对象来共享一个虚拟机，这里不展开。&lt;/p&gt;

&lt;h4 id=&quot;0x032引擎启动&quot;&gt;0x032.引擎启动&lt;/h4&gt;

&lt;p&gt;引擎启动之后，框架会通过上述的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;执行一个叫作&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;的文件，这个文件是框架的重点之一，我把他归结为两个功能:1.收集并解析热更脚本的数据。2.将解析完的数据交还给Native处理。&lt;/p&gt;

&lt;h4 id=&quot;0x033解析脚本方法替换&quot;&gt;0x033.解析脚本/方法替换&lt;/h4&gt;

&lt;p&gt;拉取脚本我觉得没什么好说的，下面讲讲脚本解析，挑demo中最简单的一个例子来讲&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;UIViewController&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;defineClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;JPViewController&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;handleBtn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tableViewCtrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;UIViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;navigationController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pushViewController_animated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tableViewCtrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;YES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;这里为什么对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt;，是因为在下面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleBtn&lt;/code&gt;这个方法中使用了这个类，&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require&lt;/code&gt;方法在当前全局中保存了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewContrller&lt;/code&gt;这个对象，防止在进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController.alloc().init()&lt;/code&gt;方法的链式调用中不会出现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewContrller is not defined&lt;/code&gt;的报错。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defineClass = function(declaration, properties, instMethods, clsMethods){...}&lt;/code&gt;方法传入的是类的声明，属性、实例方法、类方法。而例子中第二个参数传入是一个实例方法的map，是因为作者在其中发现第二个参数不是数组的情况下，就会把第二个参数当作实例方法往前提。之后会把解析完的脚本数据通过native早就准备好的方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_OC_defineClass&lt;/code&gt;，进行处理：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;_OC_defineClass&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classDeclaration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JSValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instanceMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JSValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defineClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classDeclaration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instanceMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;其实OC的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defineClass&lt;/code&gt;方法内部的细节很多，当然本质就是进行方法替换，作者先将将方法转发的方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&lt;/code&gt;进行了替换，再将热更脚本收集的方法全部挂到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;替换的方法转发方法&lt;/code&gt;上(第一次会有点饶，可以多看几遍源码)，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSInvocation&lt;/code&gt;对象包含所有的方法入参和方法签名，非常适合在这里进行方法的调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当然&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController.alloc().init()&lt;/code&gt;类似的语句是做不到直接调用的，因为js中压根没有这些方法，作者博客也有讲到，所以另辟蹊径。在这一步，&lt;a href=&quot;https://github.com/bang590/JSPatch/blob/master/JSPatch/JSPatch.js&quot;&gt;JSPatch.js&lt;/a&gt;会通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;正则&lt;/code&gt;对热更脚本进行一轮胶水代码的添加，在解析阶段，上述这句话会变成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)()&lt;/code&gt;，这样通过一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__c&lt;/code&gt;的统一的胶水函数，就能非常方便地把诸如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;方法交还给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;native&lt;/code&gt;进行调用了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是大致的执行流程了，当前其中还有很多复杂的细节，比如返回值的处理，上面只是讲到无返回值类型最简单的一种。各种参数类型的处理，各种语法的处理比如block，结构体，用libffi处理C函数等等。&lt;/p&gt;

&lt;p&gt;前段时间，在重读源码的过程中，逮住了一只野生的bang大佬，问了几个细节问题，收到了解答也是非常的开心。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-13671612c5ec6ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x34-小结&quot;&gt;0x34 小结&lt;/h4&gt;

&lt;p&gt;总的来说&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;是一个非常优秀的热更框架，作者也是一步步精益求精，满足了广大开发者的各种诉求。思路和实现都非常值得阅读和学习，目前github还在维护的热更框架采用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;作为脚本语言的基本都是学习了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;思路，例如这个&lt;a href=&quot;https://github.com/yangyangFeng/TTPatch&quot;&gt;TTPatch&lt;/a&gt;（真没看出啥大区别…）。当然此类的解决方案虽然还是有过审的可能，但是大家渐渐地开始不太敢用了，毕竟被下架付出的成本远远比线上bug的成本高多了，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSContext&lt;/code&gt;进行动态化太容易被机审扫到了。&lt;/p&gt;

&lt;h2 id=&quot;0x04mango&quot;&gt;0x04.&lt;a href=&quot;https://github.com/YPLiang19/Mango&quot;&gt;Mango&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;第二个为什么选这个框架呢，因为第一次看到这个框架的时候，还是比较眼前一亮的，这个框架就是我所说的自制语言和自制编译器/解释器的代表型框架。具体可以看作者原理与使用介绍&lt;a href=&quot;https://www.jianshu.com/p/7ae91a2daead&quot;&gt;MangoFix：iOS热修复另辟蹊径&lt;/a&gt;，总的来说，开发者可以使用一种以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.mg&lt;/code&gt;为后缀的脚本文件，文件内容类似OC的语法，所以可以很快上手，之后同样对脚本进行解析，不同于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSPatch&lt;/code&gt;的方法转发，Mango是直接通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libffi&lt;/code&gt;进行了方法替换。在研究框架的过程中，我发现如此优秀的轮子，网上关于的源码阅读和解释的文章缺很少，所以今天我想特别来说说。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;![img](https://upload-images.jianshu.io/upload_images/1709476-16c9960a772355e4.png?imageMogr2/auto-orient/strip&lt;/td&gt;
      &lt;td&gt;imageView2/2/w/810/format/webp)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;原理部分，我照搬了作者的原图。接下来具体来说说技术的实现点。&lt;/p&gt;

&lt;h4 id=&quot;0x041lexyacc&quot;&gt;0x041.Lex&amp;amp;&amp;amp;Yacc&lt;/h4&gt;

&lt;p&gt;作者在脚本的解析中用到了该工具，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lex&amp;amp;&amp;amp;Yacc&lt;/code&gt;可以让你轻易的解析复杂的语言，当你需要读取一个配置文件时，或者你需要编写一个你自己使用的语言的编译器时，你不用手工写解析器，他可以直接帮你做到你想要的事。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lex&lt;/code&gt;负责词法的分析，将脚本切割成一个个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yacc&lt;/code&gt;负责解析语法分析，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将token&lt;/code&gt;按照你写的规则生成抽象语法树。注意 Lex 和 Yacc 都是基于正则表达，后面讲到。&lt;/p&gt;

&lt;h4 id=&quot;0x042bnf&quot;&gt;0x042.BNF&lt;/h4&gt;

&lt;p&gt;什么是BNF？总的来说BNF是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一个描述语法规则的语言&lt;/code&gt;。具体可以我上一篇&lt;a href=&quot;https://www.jianshu.com/p/d2c2ea279053&quot;&gt;编译原理（1）&lt;/a&gt;简单地介绍了一下BNF，不是啥新东西，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Yacc&lt;/code&gt;同样可以通过BNF提取语法规则。&lt;/p&gt;

&lt;h4 id=&quot;0x043脚本解析&quot;&gt;0x043.脚本解析&lt;/h4&gt;

&lt;p&gt;掌握了以上几个知识点，去理解原理也就变得不那么难了，还是找一个最简单的例子来聊聊。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequentialStatementExample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面是一个mg文件，可以看到和OC非常像，但是又有一些不一样。可以看到，该脚本目的是改掉原始&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sequentialStatementExample&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;1.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lex&lt;/code&gt; 部分:首先通过正则把关键字匹配出来，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewController&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;1&quot;&lt;/code&gt;一个个切出来，就是上述的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;void&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VOID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//void关键字&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;class&quot;&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CLASS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//class关键字&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Za&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Za&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z_&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf_create_identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yytext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;yylval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_retained&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//标识符 例如ViewController、UIViewController&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COLON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//分号&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; {&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;    mf_open_string_literal_buf();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;    BEGIN STRING_LITERAL_STATE;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;} //第一次匹配到&apos;&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&apos;开始进入字符串收集状态&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STRING_LITERAL_STATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;mf_append_string_literal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yytext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//匹配换行符之外的任意字符,字符串进行拼接&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STRING_LITERAL_STATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; {&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	MFExpression *expression = mf_create_expression(MF_STRING_EXPRESSION);&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	expression.cstringValue = mf_end_string_literal();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	yylval.expression = (__bridge_retained void *)expression;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	BEGIN  INITIAL;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;	return STRING_LITERAL;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;} //在字符串状态匹配到&apos;&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&apos;，意味字符串匹配结束，继续进入首字符匹配模式&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yylval&lt;/code&gt;其中保存着相关的信息，这个信息就是在词法分析文件中(lex)进行设置的，而在语法分析文件中(yacc)就直接采用了
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yytext&lt;/code&gt; 是指向所匹配的字符串的指针（以 NULL 结尾），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yytext[0]&lt;/code&gt;就是当前首字符，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yyleng &lt;/code&gt;是这个字符串的长度。&lt;/p&gt;

&lt;p&gt;2.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Yacc&lt;/code&gt;部分刚开始啃确实会有一点难理解，先来个简单的，如何匹配一个实例方法&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nl&quot;&gt;instance_method_definition:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annotation_if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SUB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type_specifier&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method_name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_statement&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFExpression&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotaionIfConditionExpr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MFExpression&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFTypeSpecifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returnTypeSpecifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MFTypeSpecifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFBlockBody&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_transfer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MFBlockBody&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;MFMethodDefinition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodDefinition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf_create_method_definition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotaionIfConditionExpr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnTypeSpecifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
				&lt;span class=&quot;err&quot;&gt;$$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__bridge_retained&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodDefinition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;annotation_if 可以是empty，SUB = ‘-‘， LP = ‘{‘  ，type_specifier = ‘返回类型’ ，RP = ‘}’  ，method_name = ‘函数名’ ，block_statement = ‘函数体’ ，这样就可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instance_method_definition&lt;/code&gt;匹配出一个实例方法了。但真正能把上述这个简单的脚本匹配出来需要还经过层层匹配，我稍微总结了一下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;member_definition_list : member_definition | member_definition_list member_definition;

member_definition : property_definition | method_definition

method_definition : instance_method_definition | class_method_definition;
 
instance_method_definition : annotation_if &quot;-&quot; &quot;(&quot; type_specifier &quot;)&quot; method_name block_statement

type_specifier : void | BOOL | Class | id | ... 

block_statement : &quot;{&quot;  statement_list  &quot;}&quot;

statement_list : statement | statement_list statement

statement : declaration_statement | if_statement | switch_statement | for_statement | foreach_statement | while_statement | do_while_statement | break_statement | continue_statement | return_statement | expression_statement
			
expression_statement : expression &quot;;&quot;

expression : assign_expression

assign_expression : ternary_operator_expression | primary_expression assignment_operator ternary_operator_expression

ternary_operator_expression : logic_or_expression  | logic_or_expression &quot;?&quot; ternary_operator_expression &quot;:&quot; ternary_operator_expression |
logic_or_expression  &quot;?&quot; &quot;:&quot; ternary_operator_expression

logic_or_expression : logic_and_expression | logic_or_expression &quot;||&quot; logic_and_expression

logic_and_expression : equality_expression | logic_and_expression &quot;&amp;amp;&amp;amp;&quot; equality_expression

equality_expression : relational_expression | equality_expression &quot;==&quot; relational_expression | equality_expression &quot;!=&quot; relational_expression

relational_expression: additive_expression | relational_expression &quot;&amp;lt;&quot;| &quot;&amp;lt;=&quot; | &quot;&amp;gt;&quot; | &quot;&amp;gt;=&quot;  additive_expression

additive_expression : multiplication_expression | additive_expression &quot;+&quot; multiplication_expression | additive_expression &quot;-&quot; multiplication_expression

multiplication_expression : unary_expression | multiplication_expression &quot;*&quot; unary_expression

unary_expression : postfix_expression | &quot;!&quot; unary_expression | &quot;-&quot; unary_expression

postfix_expression : primary_expression | primary_expression &quot;++&quot; | primary_expression &quot;--&quot;

primary_expression : IDENTIFIER | &quot;&amp;amp;&quot; IDENTIFIER | primary_expression &quot;.&quot; IDENTIFIER | primary_expression &quot;.&quot; key_work_identifier | primary_expression &quot;.&quot; selector &quot;()&quot; ｜ primary_expression &quot;.&quot; selector &quot;(&quot; expression_list &quot;)&quot; 

|  primary_expression &quot;(&quot; &quot;)&quot; |  ...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就一个简单的实例方法需要经过这么多规则的筛选，不得不佩服作者细腻的逻辑能力，其实这之中也有非常多的细节，你要做很多二义性的判断，各种特殊情况的处理，我觉得这个工作量绝对是不小的。&lt;/p&gt;

&lt;p&gt;话说回来光匹配是不够的，在匹配过程中，还需要生成AST(抽象语法树)。比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$1、$2&lt;/code&gt;这类就是获取匹配出来的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yylval.expression&lt;/code&gt;，数字代表顺序代表匹配的token顺序，例如上述&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MFTypeSpecifier *returnTypeSpecifier = (__bridge_transfer MFTypeSpecifier *)$4;&lt;/code&gt;就是把第四个token，方法的返回类型，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returnTypeSpecifier&lt;/code&gt;接收。又比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$$&lt;/code&gt;就代表把收集的语义封装的对象继续向上传递。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PS:我自己有个疑问，yacc在层层向上匹配的过程中，如果发现自己匹配错了会怎么样呢？是回溯吗？，还是在匹配过程中，他已经已经知道自己要走哪条路了？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解析完之后，会得到一个个的AST的对象保存在内存中，比如方法对象就是保存在NSMutableDictionary当中。之后通过libffi进行方法替换。&lt;/p&gt;

&lt;h4 id=&quot;0x044方法执行&quot;&gt;0x044.方法执行&lt;/h4&gt;

&lt;p&gt;方法执行的逻辑也挺复杂，不断地计算AST的节点。各个语法树节点对象的类都需要具备类型（赋值、if语句、for循环、switch等等条件都会进到不一样的执行逻辑当中）和执行的表达式。eval方法将计算与以该节点为根的子树对应的语句、表达式及子表达式，并返回执行结果。一直执行，执行到根节点为止。作者在这一块可以说实现了一整个解释器/虚拟机。&lt;/p&gt;

&lt;h4 id=&quot;0x045小结&quot;&gt;0x045.小结&lt;/h4&gt;

&lt;p&gt;其实这个框架让我佩服的点是他完成了自制语言整个编译+解释的过程，虽不知道作者是何许人也，但是大佬的底层功力不可谓不深厚。尤其是编译原理，搞得相当的明白，我这种入门级小白只能顶礼膜拜。业界也有在大佬基础上进行更进一步探索的比如:&lt;a href=&quot;https://github.com/SilverFruity/OCRunner&quot;&gt;OCRunner&lt;/a&gt;，和该作者简单的聊了一下，作者本身只想做一个将OC语言翻译成mg文件的工具，最后干脆自己直接实现了从OC到AST的过程，我认为这个方向也很不错，毕竟开发者上手一门新的脚本语言，还是需要学习成本的。但是作者也表示，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lex&amp;amp;&amp;amp;Yacc&lt;/code&gt;来作为OC的翻译工具还是有很多坑，比如识别&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; ——&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSString *a 和 a * b&lt;/code&gt; 具有二义性的需要特殊处理， 也处理不了头文件的展开。作者最后说如果有机会可能会直接上clang，我：…………………..&lt;/p&gt;

&lt;h2 id=&quot;0x05总结&quot;&gt;0x05.总结&lt;/h2&gt;

&lt;p&gt;热更经过这么多年的发展，方案五花八门，但以上讲到的两种方案是最具代表性的，只要将热更做到安全可控，我相信热更还是有未来的，篇幅有限，先到这里。你知道的越多，你不知道的越多。&lt;/p&gt;

&lt;h2 id=&quot;0x06参考&quot;&gt;0x06.参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bang590&quot;&gt;bang590&lt;/a&gt;/&lt;a href=&quot;https://github.com/bang590/JSPatch&quot;&gt;JSPatch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/YPLiang19&quot;&gt;YPLiang19&lt;/a&gt;/&lt;a href=&quot;https://github.com/YPLiang19/Mango&quot;&gt;Mango&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Jun 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/06/21/%E8%81%8A%E8%81%8A%E7%83%AD%E6%9B%B4%E6%96%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/06/21/%E8%81%8A%E8%81%8A%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
        
        <category>热更新</category>
        
        
      </item>
    
      <item>
        <title>C++语法笔记</title>
        <description>&lt;p&gt;最近需要用C++做一些跨平台的组件，我自己本身对C++的语法不是特别熟练，也算是边写边学。
记录了一些平时开发过程中用到的语法笔记。&lt;/p&gt;

&lt;p&gt;1.C++支持函数重载，C不支持。底层用了namemangling技术，通过编译器把函数名字改掉，每个方法名不一样。不同编译器有不同的生成规则。&lt;/p&gt;

&lt;p&gt;2.extern “C”:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;被extern “C” 修饰的代码会按照C语言的方式去编译。&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;func()&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果函数同时有声明和实现，要让函数声明被extern “C” 修饰，函数的实现可以不修饰。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如有两个函数是通过.c（C语言）的方式进行实现的，那么在cpp的文件中，假如想使用这两个函数的话，不仅要声明，并且需要的在声明外要用 extern “C”  修饰。告诉编译器，这两个方法是用C语言来实现的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当然也可以这么写&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;cp&quot;&gt;#include &quot;math.h&quot;//include的作用:把math.h的内容原封不动的拷贝一份。
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么一个函数声明既要给C调用又要给C++调用怎么办呢？用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cplusplus&lt;/code&gt;宏来判断你是否在C++的环境&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;    
  &lt;span class=&quot;c1&quot;&gt;//这里是是你的声明或者代码,xxx&lt;/span&gt;
    
&lt;span class=&quot;cp&quot;&gt;#ifdef __cplusplus 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.防止重复include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基于include只是执行了copy操作，所以include多次在语法上都没啥问题，但是代码量会增多，因此为了防止多次include&lt;/p&gt;

    &lt;p&gt;可以用以下代码:首次未定义才进入声明逻辑。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#ifndef ABC
#define ABC
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;xxx&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;或者可以用编译器的特性&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; #pragma once &lt;/code&gt;来指名头文件只包含一次。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两者区别:第一种不受编译器的任何限制，是标准语法。第二种老编译器不支持，兼容性不够，只针对整个文件。&lt;/p&gt;

&lt;p&gt;4.inline内联函数:本质把方法替换成具体实现，可以减少函数调用的开销，会增大代码体积会。但inline只是仅仅是建议编译器进行替换，有时候声明了也不一定起作用，比如:递归。递归是无法内联的。&lt;/p&gt;

&lt;p&gt;内敛函数和宏都可以减少函数的开销，对比宏，内敛函数有函数的特性，有代码提示。&lt;/p&gt;

&lt;p&gt;5.const:被修饰的变量不可修改&lt;/p&gt;

&lt;p&gt;如果修饰的是类或者结构体，那么其中的成员也不可更改。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const修饰右边的东西&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//int * 是一个int指针 p是具体的值&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//修改p指向的具体值&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//修改p的值&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// p1是常量，*p1是常量，所以不能改年龄&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 和p1没区别&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//p3是常量，*p3不是，因此可以年龄。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//两个都不能改&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//两个都不能改&lt;/span&gt;
 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.引用&lt;/p&gt;

&lt;p&gt;在C++ 中，引用可以起到跟指针类似的功能，但指针可以修改，引用必须初始化，一旦指向了某个变量，就不可以再改变。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;refAge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;价值:比指针更安全。因为指针在中途可以修改指向，引用不能。&lt;/p&gt;

&lt;p&gt;本质:引用是弱化了的指针。本质是指针&lt;/p&gt;

&lt;p&gt;7.this&lt;/p&gt;

&lt;p&gt;通常一个对象的成员变量是在对象当中的，而函数是放在代码段的，为了在函数体内用this能访问到对象本身，这里有个一个隐式参数，把对象地址传入函数体中，然后将对象地址给this进行赋值&lt;/p&gt;

&lt;p&gt;8.堆的申请和释放&lt;/p&gt;

&lt;p&gt;new和delete或者new[]和delete[]必须成对出现&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//申请连续的4个字节、*p指向第一个。char类型的数组&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;11&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//给第一个字节赋值&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;12&quot;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//给第二个字节赋值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//p的4个字节每一个字节都是1&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.析构函数&lt;/p&gt;

&lt;p&gt;对象销毁时，进行调用，通过malloc分配的对象free时不会调用析构函数，声明为pulic才能被外界正常使用。&lt;/p&gt;

&lt;p&gt;构造方法的顺序和析构的顺序相反。&lt;/p&gt;

&lt;p&gt;构造函数: 父类构造-&amp;gt;子类构造&lt;/p&gt;

&lt;p&gt;析构函数: 子类析构-&amp;gt;父类析构&lt;/p&gt;

&lt;p&gt;10.多态&lt;/p&gt;

&lt;p&gt;定义:同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。&lt;/p&gt;

&lt;p&gt;方法的调用，默认看指针类型进行操作，不看实际的对象类型是什么。&lt;/p&gt;

&lt;p&gt;很多语言默认支持多态，C++要实现多态，需要用到虚函数。&lt;/p&gt;

&lt;p&gt;11.虚函数&lt;/p&gt;

&lt;p&gt;定义:被virtual修饰的成员函数&lt;/p&gt;

&lt;p&gt;只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（子类可以省略virtual关键字）&lt;/p&gt;

&lt;p&gt;1.有虚函数存在一个类顶部会多4个字节，这个4个字节存放的是虚表（虚函数表）的地址，虚表里面有每个虚函数的方法地址。&lt;/p&gt;

&lt;p&gt;2.所有对象共用一张虚表。（如果是多继承就多张虚表）&lt;/p&gt;

&lt;p&gt;3.因此如果父类指针指向子类对象，析构函数也应该定义为虚函数。否则释放时无法调用子类的虚函数。&lt;/p&gt;

&lt;p&gt;12.模版&lt;/p&gt;

&lt;p&gt;模版的本质类似范型，编译器会为多类型的入参生成多个类型的函数。&lt;/p&gt;

&lt;p&gt;13.类型转换&lt;/p&gt;

&lt;p&gt;static_cast:普通转换，不支持交叉转换。&lt;/p&gt;

&lt;p&gt;dynamic_cast:支持交叉转换，会做安全计算。&lt;/p&gt;

&lt;p&gt;reinterpret_cast:简简单单的二进制复制。&lt;/p&gt;

&lt;p&gt;const_cast:把const转换成非const。&lt;/p&gt;

&lt;p&gt;14.nullptr可以解决NULL的二义性（既代表0又代表空指针）&lt;/p&gt;

&lt;p&gt;15.智能指针&lt;/p&gt;

&lt;p&gt;传统指针存在的问题:&lt;/p&gt;

&lt;p&gt;1.需要手动管理内存。&lt;/p&gt;

&lt;p&gt;2.容易发生内存泄漏。&lt;/p&gt;

&lt;p&gt;3.释放之后产生野指针。&lt;/p&gt;

&lt;p&gt;智能指针可以解决这些问题。&lt;/p&gt;

&lt;p&gt;实现原理类似于装箱和拆箱，用一个内部私有指针保存对象。在释放时，自动释放私有的内部指针。&lt;/p&gt;

</description>
        <pubDate>Wed, 09 Jun 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/06/09/CPP%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/06/09/CPP%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</guid>
        
        <category>C++</category>
        
        
      </item>
    
      <item>
        <title>编译原理（一）</title>
        <description>&lt;p&gt;最近在看基于DSL的热更新框架，瞬间对编译器原理产生了浓厚的兴趣。百度、知乎了很久，给自己定了一套学习路径(🐶)。龙书，虎书，鲸书这些是必看的，但是书还在路上。《Engineering a Compiler》和《游戏脚本高级编程》看起来口碑也不错。不过我的入门，从一本叫《两周自制脚本语言》开始（以下简称《两周》）。希望这个主题会有第二篇、第三篇….吧。&lt;/p&gt;

&lt;h2 id=&quot;0x01前言&quot;&gt;0x01.前言&lt;/h2&gt;

&lt;p&gt;在计算机的世界里，计算机的底层执行逻辑一定是通过二进制的命令结合硬件电路实现的。硬件看不懂我们的代码，它们只知道把高电压当成1，低电压当成0，执行过程就是一次次放电过程。所以程序本质上是一串很长很长的的二进制数字，由于不易阅读，人们常通过汇编语言程序来表达这个巨大的数字。程序只有载入内存后才能通过硬件执行。因此，用户在实际使用的时候，必须先通过软件从磁盘文件中读取机器语言程序，再将复制到内存中，这类程序称不上时语言处理器，通常称为操作系统。&lt;/p&gt;

&lt;p&gt;而计算机是如何将高级语言变成机器语言的呢？这里就需要用到语言处理器，其实语言处理器在我们的工作中时时刻刻都在接触。这之中大致分两种:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编译器：将某种语言写成的程序转换成另一种语言的程序。通常会将源程序转化为机器语言程序。编译器转化程序的行为称为编译。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解释器：根据程序中的算法执行运算。简单来讲，它时一种用于执行程序的软件。如果执行的程序由虚拟机器语言或类似于机器语言的程序设计语言写成，这种软件也能称为虚拟机，例如JS，Python等脚本语言。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java语言会特殊一些，首先会通过编译器把源代码转化成Java字节码，并将这种虚拟的机器语言保存在文件中。之后,Java虚拟机的解释器将执行这些代码。大多数Java虚拟机为了提高性能，会在执行过程中通过编译器将一部分Java字节码直接转化为机器代码使用，执行过程中进行搞得机器语言转化称为动态编译或JIT编译，转化后得到的机器语言将被载入内存，由硬件执行，无需使用解释器。&lt;/p&gt;

&lt;p&gt;过去人们提到编译器时，首先会联想编译过程非常耗时。不过由于编译后实际执行的是机器语言，因此执行速度很快。而对于解释器，人们通常认为它会在程序输入的同时立即执行，执行速度较慢。这就是两者的基本区别。现代的解释器内部常采用各种类型的编译器，已经越来越没必要将解释器与编译器区分看待。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-dd506a10bd81b27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;编译的大致过程&quot; title=&quot;编译的大致过程&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;0x02词法分析&quot;&gt;0x02.词法分析&lt;/h2&gt;

&lt;p&gt;语言处理器的第一个组成部分是词法分析。程序的源代码本质只是一长串字符串，这样的字符串很难处理，语言处理器通常会首先将字符串中的字符以单词为单位分组，切割成多个子字符串。这就是词法分析&lt;/p&gt;

&lt;h3 id=&quot;token对象&quot;&gt;token对象&lt;/h3&gt;

&lt;p&gt;下面是某个程序中的一行代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;while i &amp;lt; 10 {
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;词法分析会把它拆分为下面这样的字符串&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&quot;while&quot; &quot;i&quot; &quot;&amp;lt;&quot; &quot;10&quot; &quot;{&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这句代码被分割为了5个字符串。通常把词法分析的结果称为单词（token），当然可能你的换行会变成一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;\n&quot;&lt;/code&gt;的token，注释标志也可能会变成一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/*&quot;&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;*/&quot;&lt;/code&gt; 两个token，这都是有可能的，具体看编译器是如何工作的。当然具体是怎么切的，《两周》这本书用的是正则匹配:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0-9]+&lt;/code&gt;来匹配整型。&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[A-Z_a-z][A-Z_a-z0-9]*&lt;/code&gt;(以字母、下划线开头，之后仅包含有字母、数字、下划线)来匹配标识符，（是不是很像我们平时定义变量?，不可以用数字开头）&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;执行词法分析时，语言处理器会逐行读取源代码，从各行开头起检查内容是否与该正则表达式匹配，并在检查完后获取与正则表达式括号内的模式相匹配的字符串。&lt;/p&gt;

&lt;p&gt;在这一步中，空格、换行、注释这些都会被分析器所忽略。编译器会事先获知之后取得的单词，一边获取一边构造抽象语法树，在中途发现构造有误时，需要退回若干单词，重新构造语法树，称之为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;回溯&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;0x03语法分析ast抽象语法树&quot;&gt;0x03.语法分析/AST(抽象语法树)&lt;/h2&gt;

&lt;p&gt;语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树。抽象语法树（AST，Abstract Syntax Tree）是一种用于表示程序结构的树形结构。语法分析的主要任务是分析单词之间的关系，如判断哪些单词属于同一个表达式或语句，以及处理左右括号（单词）的配对等问题。这一阶段还会检查程序中是否含有语法错误。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;13 + x * 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们对上面这条语句进行词法分析。我们通过上面的分析可以得出，编译器大致会分割成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;13&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; +&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; x&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; *&lt;/code&gt; 、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;，这几个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后我们将这些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;进行重新排列，变成一个抽象语法树，每个叶节点存储着具体的值和值的类型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-60b4d19edf3a6cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;，在进行语法树构建的过程中，符号其实是有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;优先级&lt;/code&gt;以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;左右结合顺序&lt;/code&gt;的，后面会提到。&lt;/p&gt;

&lt;h2 id=&quot;0x04bnf&quot;&gt;0x04.BNF&lt;/h2&gt;

&lt;p&gt;什么是BNF？总的来说BNF是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一个描述语法规则的语言&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;初次理解BNF会觉得很难懂，至少我是理解了好久。如果看文字实在太绕，建议看视频，https://www.bilibili.com/video/BV1Us411h72K?from=search&amp;amp;seid=14895223797156770591 我是看了这个视频之后开窍了（我居然可以在bilibli学技术）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BNF中常用的元字符及其表示的意义如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;在双引号中的字 &quot;word&quot; 代表着这些字符本身。而double_quote用来代表双引号；
在双引号外的字（有可能有下划线）代表着语法部分；
尖括号 &amp;lt; &amp;gt; 内包含的为必选项；
方括号 [ ] 内包含的为可选项；
大括号 { } 内包含的为可重复0至无数次的项；
圆括号 ( ) 内包含的所有项为一组，用来控制表达式的优先级；
竖线 | 表示在其左右两边任选一项，相当于&quot;OR&quot;的意思；
::= 是“被定义为”的意思；
...  表示术语符号；
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;理解了上面这些符号的规则，可以来看看书中对自制语言的规则描述:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;primary ::=  &quot;(&quot; expr &quot;)&quot; | NUMBER | IDENTIFIER | STRING
factor ::=  &quot;-&quot; primary | primary
expr ::= factor { OP factor }
block ::=  &quot;{&quot; [ statement ] { (&quot;;&quot; | EOL) [ statement ]} &quot;}&quot;
simple ::=  expr
statement ::= &quot;if&quot; expr block [ &quot;else&quot; block ] | &quot;while&quot; expr block | simple
program ::=  [ statement ] (&quot;;&quot; | EOL)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;非终结符factor（因子）或表示一个primary，或表示primary之前再添加一个-号的组合&lt;/p&gt;

&lt;p&gt;expr（表达式）用于表示两个factor之间夹有一个双目运算符的组合&lt;/p&gt;

&lt;p&gt;block（代码块）指的是由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;括起来的statement（语句）序列&lt;/p&gt;

&lt;p&gt;statement之间需要用分号或换行符（EOL）分隔。由于Stone 语言支持空语句，因此规则中的statement两侧写有中括号[]。可以看到，它的结构大致与expr类似。它们都由其他的非终结符（statement或factor）与一些用于分隔的符号组合而成&lt;/p&gt;

&lt;p&gt;statement可以是if语句、while语句或仅仅是简单表达式语句（simp1e）。简单表达式语句是仅由表达式（expr）构成的语句。&lt;/p&gt;

&lt;p&gt;最后的program（程序）是一个非终结符，它可以包含分号或换行符，用于表示一句完整的语句。其中，statement可以省略，因此program还能用来表示空行。代码块中最后一句能够省略句尾分号与换行符。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;想要彻底理解BNF，递归的思想是必不可少的&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;假如以上BNF规定了语言语法的时候，在进行抽象语法树组合的时候，如果不符合以上制定的这些规则时，编译器就会抛出异常。&lt;/p&gt;

&lt;p&gt;例如:最后声明的program（程序），你只能用分号或者换行符作为结束符，你想用用句号（。）作为结束符，是不被允许的。&lt;/p&gt;

&lt;h2 id=&quot;0x04解释器执行&quot;&gt;0x04.解释器执行&lt;/h2&gt;

&lt;p&gt;语法分析将从词法分析器逐一读取非终结符program。即，以语句为单位读取单词，并进行语法分析，执行语法分析后得到的抽象语法树。只要通过语法分析得到抽象语法树，剩下的就简单了，只要从根结点开始遍历至叶节点，并计算各节点的内容即可，这就是解释器的基本实现原理。&lt;/p&gt;

&lt;p&gt;要根据得到的抽象语法树来执行程序，各个语法树节点对象的类都需要具备eval方法。eval是evaluate（求值）的缩写。eval方法将计算与以该节点为根的子树对应的语句、表达式及子表达式，并返回执行结果。一直执行，执行到根节点为止。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-4b57eb08639b8933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;看虚线方向就是执行方向&quot; title=&quot;看虚线方向就是执行方向&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;其实这同样是一种递归过程&lt;/code&gt;，&lt;/p&gt;

&lt;h2 id=&quot;0x05编译器&quot;&gt;0x05.编译器&lt;/h2&gt;

&lt;p&gt;在使用中间代码解释器时，我们要事先将抽象语法树转换为中间代码。简单来说，中间代码是一种虚拟的机器语言，因此，中间代码的转换方法，其实与编译器将抽象语法树转换为真正的机器语言时采用的方法大体相同。&lt;/p&gt;

&lt;h4 id=&quot;中间代码与机器语言&quot;&gt;中间代码与机器语言&lt;/h4&gt;

&lt;p&gt;之间利用抽象语法树，语言处理器需要在节点之间往返操作，这是一件费时的工作。因此，如果语言处理器能够实现计算遍历顺序，并以此重新排列节点，执行开销就可能有所降低&lt;/p&gt;

&lt;p&gt;通常，语言处理器不会直接将重新排列的抽象语法树节点作为中间代码使用。如果直接保存抽象语法树的节点，多余的无用信息是一种空间上的浪费，因此，我们需要设计一种虚拟的机器语言，并将各个节点转换为与该节点运算逻辑对应的机器语言。大多数语言处理器使用的中间语言都是这种转换后的代码（见下图）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-b409299e7b66b062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虚拟机由若干个通用寄存器与内存组成。内存分为四个区域，分别是栈（stack）区、堆（heap）区、程序代码区与文字常量区。虚拟机器语言保存于程序代码区，字符串字面量保存干文字常量区。&lt;/p&gt;

&lt;p&gt;本书作者自己实现了一个自制的虚拟机，在程序启动过程中同时启动虚拟机，对于抽象语法树的操作不再是简单的执行，而是首先将语言转为虚拟机语言，再通过汇编执行函数的思路进行执行。不过本书中的程序为了演示虚拟机的工作原理并没有给程序性能带来提升，因为自制的语言是程序启动过程中进行编译，执行。不如直接执行抽象语法树来的直接。&lt;/p&gt;

&lt;h2 id=&quot;0x06总结&quot;&gt;0x06.总结&lt;/h2&gt;

&lt;p&gt;其实书中的细节还有很多，作者对自制的语言也加入很多功能，比如函数，静态变量、闭包等等。在实现局部和全部变量时，居然讨巧的用了一个hashmap + namespace来实现，来确保变量的作用域，这真的非常有意思。&lt;/p&gt;

&lt;p&gt;看了这本书，算是对编译原理有一个入门级的认识吧， 取名（1），希望鞭策自己这个主题会有第二篇、第三篇….吧。&lt;/p&gt;

&lt;p&gt;众所周知，目前程序的编译器基本都是C++实现的，但是第一个C++程序又是谁给编译的呢？都知道蛋是鸡生的，那么第一只鸡是哪来的呢？&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;所谓C语言编译器，就是把编程得到的文件，比方.c,.h的文件，进行读取，并对内容进行剖析，按照C语言的规则，将其转换成体系能够履行的二进制文件。
其本质在于对文件的读入，剖析，及处理。这些操作，C言语都是能够完成的。所以用C言语来做C言语的编译器是彻底可行的。
可是，历史上的第一个C言语编译器，必定不是C言语写的，因为在没有编译器时，无法把C言语转换成可履行文件。
只需有了第一版其它言语的编译器，就能够用C言语写编译器了。事实上，现在大多数的C言语编译器，都是用C言语写的。
首要你要理解编译的意思，它是指把高档言语翻译成计算机 能读懂的低级言语（二进制代码），这样计算机才会履行你 的指令，
编译器就相当于一个翻译，在翻译的过程中还会检 查你语法上有没有错误 C言语编译器自然是把用C言语写的程序翻译成二进制代码咯。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;0x07参考&quot;&gt;0x07.参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Bm5n8qovMrRMxE0MRZMGKw&quot;&gt;两周自制脚本语言&lt;/a&gt;/提取码: t8qm&lt;/p&gt;

&lt;p&gt;https://github.com/wmathor/Stone-language&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/30023409&quot;&gt;世界上第一个编译器是怎么来的？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Us411h72K?from=search&amp;amp;seid=14895223797156770591&quot;&gt;编程范式02BNF&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 09 May 2021 14:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E4%B8%80/</guid>
        
        <category>编译原理</category>
        
        
      </item>
    
      <item>
        <title>彻底搞懂HashMap</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;关于Java的HashMap的资料真的太多了，用被研究“烂”了形容也一点不过分😂，此篇文章就几个疑难问题加上自己这两天的研究，做个总结。&lt;/p&gt;

&lt;h3 id=&quot;1原理实现细节总结&quot;&gt;1.原理实现细节总结&lt;/h3&gt;

&lt;p&gt;1.hashMap在Jdk1.7和1.8略有不一样，1.7是数组+链表，1.8是数组+链表+红黑树。&lt;/p&gt;

&lt;p&gt;2.通过系统提供或者自定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt;算法算出key的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;&amp;amp;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table.lenth - 1&lt;/code&gt;算出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index&lt;/code&gt;，插入数组当中，时间复杂度为O(1)。&lt;/p&gt;

&lt;p&gt;3.不同的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;通过&amp;amp;运算得到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index&lt;/code&gt;可能相同，我们称之为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash collision(哈希冲突/碰撞)&lt;/code&gt;。如果出现碰撞，相同&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bucket&lt;/code&gt;将变成链表或者红黑树，1.8中当相同位置的节点大于8时会从链表变成红黑树，相反如果又变成6或者更小时会退化成链表。&lt;/p&gt;

&lt;p&gt;4.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loadfactor&lt;/code&gt;默认0.75，假设数组容量为16，那么当size为12时，数组扩容成32。之前不管是链表还是树上的节点都会重新计算index进行迁移。&lt;/p&gt;

&lt;p&gt;5.hashMap中即使会涉及到一些链表和二叉树搜索树的遍历，但get和put的时间复杂度也可以近似看成O(1)。&lt;/p&gt;

&lt;p&gt;6.当数组容量小于64的时候，当链表大于8的时候也不会树化，而是优先扩容。&lt;/p&gt;

&lt;h3 id=&quot;2为什么loadfactor是075&quot;&gt;2.为什么&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loadfactor&lt;/code&gt;是0.75&lt;/h3&gt;

&lt;p&gt;查遍网上资料，好像没有官方解释。然后看到很多文章都是乱说的，什么泊松分布之类的，都是文不对题。&lt;/p&gt;

&lt;p&gt;https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap/31401836#31401836&lt;/p&gt;

&lt;p&gt;里面第三个答案好像是现在公认的比较可信的说法。&lt;/p&gt;

&lt;p&gt;第一次看到这个还是有点懵逼，这个ln(2)是怎么算出来的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-9182b77f46249770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;昨晚我自己在书房推了一遍，这里需要用到离散概率和无穷比无穷求极限的一些大学数学基础知识。&lt;/p&gt;

&lt;p&gt;当数组的容量趋向于无穷大时，负载因子约等于0.7，小于这个值，意为”不太容易”发生hash碰撞，所以各个语言的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashMap&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loadfactor&lt;/code&gt;也略有不同。&lt;/p&gt;

&lt;h3 id=&quot;3树化问题&quot;&gt;3.树化问题&lt;/h3&gt;

&lt;p&gt;既然遍历链表的复杂度是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;，而红黑树因为有自平衡的特点复杂度是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(log(n))&lt;/code&gt;，为什么不直接用红黑树呢？&lt;/p&gt;

&lt;p&gt;因为单个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TreeNode &lt;/code&gt;需要占用的空间大约是普通 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;的两倍，这个很好理解，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TreeNode&lt;/code&gt;中有颜色属性，父节点，左右子节点等属性，所以只有当包含足够多的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; Nodes&lt;/code&gt; 时才会转成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TreeNodes&lt;/code&gt;，而是否足够多就是由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; TREEIFY_THRESHOLD&lt;/code&gt;的值决定的。而当桶中节点数由于移除或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resize&lt;/code&gt;变少后，又会变回普通的链表的形式，以便节省空间。通过查看源码可以发现，默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想，最开始使用链表的时候，空间占用是比较少的，而且由于链表短，所以查询时间也没有太大的问题。可是当链表越来越长，需要用红黑树的形式来保证查询的效率。对于何时应该从链表转化为红黑树，需要确定一个阈值，这个阈值默认为 8，并且在源码中也对选择 8 这个数字做了说明，原文如下：&lt;/p&gt;

&lt;h3&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-656c74a3f141ccc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/h3&gt;

&lt;p&gt;大概意思:&lt;/p&gt;

&lt;p&gt;如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loadfactor&lt;/code&gt;等于0.75的情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。但，顶不住我们故意把算法变得不均匀，例如下面的代码:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样一旦&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size&lt;/code&gt;过大，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashMap&lt;/code&gt;必树化。&lt;/p&gt;

&lt;p&gt;事实上，链表长度超过 8 就转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。通常如果 hash 算法正常的话，那么链表的长度也不会很长，那么红黑树也不会带来明显的查询时间上的优势，反而会增加空间负担。所以通常情况下，并没有必要转为红黑树，所以就选择了概率非常小，小于千万分之一概率，也就是长度为 8 的概率，把长度 8 作为转化的默认阈值。&lt;/p&gt;

&lt;h5 id=&quot;所以如果平时开发中发现-hashmap-或是-concurrenthashmap-内部出现了红黑树的结构这个时候往往就说明我们的哈希算法出了问题需要留意是不是我们实现了效果不好的-hashcode-方法并对此进行改进以便减少冲突&quot;&gt;所以如果平时开发中发现 HashMap 或是 ConcurrentHashMap 内部出现了红黑树的结构，这个时候往往就说明我们的哈希算法出了问题，需要留意是不是我们实现了效果不好的 hashCode 方法，并对此进行改进，以便减少冲突。&lt;/h5&gt;

&lt;h3 id=&quot;4jdk17头插问题&quot;&gt;4.JDK1.7头插问题&lt;/h3&gt;

&lt;p&gt;JDK1.7的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashMap&lt;/code&gt;在扩容时的数据迁移时，遍历节点，之后采用头倒序的方式进行迁移，也就是后遍历到的节点，会插到新数组节点的头部，这样在多线程的情况会出现循环链表的情况。&lt;/p&gt;

&lt;p&gt;下面这篇文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/1e9cf0ac07f4&quot;&gt;老生常谈，HashMap的死循环&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我觉得讲的是讲得比详细，也是比较通俗易懂的，这边不做过多的解释了。&lt;/p&gt;

&lt;p&gt;我想谈谈的是关于这个”bug”的看法:&lt;/p&gt;

&lt;p&gt;首先&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashMap&lt;/code&gt;本身就是线程不安全的，官方本身就不建议你这样使用。&lt;/p&gt;

&lt;p&gt;关于这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug&lt;/code&gt;的讨论就好比你在一个错误的情况讨论一个错误的事情。&lt;/p&gt;

&lt;p&gt;虽然我个人认为这不是一个bug，但是JDK还是在1.8修复了这个问题，改成了尾插。但&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashMap&lt;/code&gt;在1.8的多线程中同样会有别的问题。&lt;/p&gt;

&lt;p&gt;最后再来说说为什么1.7会设计成头插？&lt;/p&gt;

&lt;p&gt;有一种说法是：缓存的时间局部性原则 (新插入的数据可能会更早用到)。这一点在操作系统中有很常见的应用，例如LRU算法。&lt;/p&gt;

&lt;h3 id=&quot;5jdk18不安全问题&quot;&gt;5.JDK1.8不安全问题&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 如果没有hash碰撞则直接插入元素&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putTreeVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TREEIFY_THRESHOLD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -1 for 1st&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;treeifyBin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// existing mapping for key&lt;/span&gt;
                &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;afterNodeAccess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;afterNodeInsertion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要是在put当中发生的问题，第6行代码，如果没有hash碰撞则会直接插入元素。如果线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入第6行代码中。假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给&lt;strong&gt;覆盖&lt;/strong&gt;，发生线程不安全。&lt;/p&gt;

&lt;h3 id=&quot;6总结&quot;&gt;6.总结&lt;/h3&gt;

&lt;p&gt;学无止境&lt;/p&gt;

&lt;h2 id=&quot;感谢&quot;&gt;感谢&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/1e9cf0ac07f4&quot;&gt;老生常谈，HashMap的死循环&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dalianpai/p/14272371.html&quot;&gt;面试题：为什么 Map 桶中超过 8 个才转为红黑树？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/271137476/answer/1381341867&quot;&gt;为何hashmap默认的负载因子是0.75？应该是空间和时间的折中，背后的统计原理是什么呢？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;amp;mid=2453141934&amp;amp;idx=1&amp;amp;sn=49c4f2cef4d93f45c82886b254517bfb&amp;amp;chksm=8cf2db2dbb85523b64d0dc14df09676eda695a3da4c61bb19f4a3b52a6629de038b8c2df75ee&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0225qecomfrEOexWDxvddpBW&amp;amp;sharer_sharetime=1614236915491&amp;amp;sharer_shareid=cebd651c55dfa614fbf50b23c086289c#rd&quot;&gt;面试官：HashMap 为什么线程不安全？&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 26 Feb 2021 17:57:00 +0800</pubDate>
        <link>http://localhost:4000/2021/02/26/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/02/26/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap/</guid>
        
        <category>JAVA,HashMap</category>
        
        
      </item>
    
      <item>
        <title>一次二级指针引发的血案</title>
        <description>&lt;h4 id=&quot;原因&quot;&gt;原因&lt;/h4&gt;

&lt;p&gt;最近开发过程中因为自己的错误操作导致了一个很傻问题。感觉是一个基于内存管理，Block，指针的综合问题。整个理解下来，对上述概念有些了新的认识，觉得值得记录一次。首先非常鸣谢&lt;a href=&quot;https://www.cnblogs.com/tiantianbobo/p/11653843.html&quot;&gt;一道题考你对__autoreleasing和__block的理解&lt;/a&gt;的作者，本次记录的问题，基本也是基于作者提供的理解思路。&lt;/p&gt;

&lt;h2 id=&quot;提问&quot;&gt;提问&lt;/h2&gt;

&lt;p&gt;我把日常的业务稍微精简了成了以下代码:&lt;/p&gt;

&lt;p&gt;“网络请求，把error作为二级指针传入ViewModel的网络请求方法中，异步回写二级指针的值，最后回调打印error”&lt;/p&gt;

&lt;p&gt;流程看似很简单，也很愉快。但其实下面的代码是最后的error是打印是”NULL”。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@interface ViewModel : NSObject
@end
@implementation ViewModel

- (void)getNetWorkWithError:(NSError **)error completeBlock:(void(^)(void))block {
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        *error = [NSError errorWithDomain:@&quot;domain&quot; code:1 userInfo:nil];
        block();
    });
}

@end

void netWork() {
    NSLog(@&quot;Hello, World!&quot;);
    NSError *error;
    ViewModel *viewModel = [ViewModel new];
    [viewModel getNetWorkWithError:&amp;amp;error completeBlock:^(){
        NSLog(@&quot;%@&quot;,error);
    }];
}


int main(int argc, const char * argv[]) {
    @autoreleasepool {
        netWork();
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop run];
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;怎么改&quot;&gt;怎么改&lt;/h2&gt;

&lt;p&gt;先说答案，有两个思路&lt;/p&gt;

&lt;p&gt;1.第一种，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt;的修饰符直接改成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSError *error;&lt;/code&gt; 改成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static NSError *error;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.第二种，改两处，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSError *error&lt;/code&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__block&lt;/code&gt;修饰，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt;必须先创建再传入参数。&lt;/p&gt;

&lt;p&gt;``` 12NSLog(@”Hello, World!”);
  __block NSError *error;&lt;/p&gt;

&lt;p&gt;ViewModel *viewModel = [ViewModel new];&lt;/p&gt;

&lt;p&gt;void(^bb)(void) = ^{&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;		NSLog(@&quot;%@&quot;,error);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;};
  [viewModel getNetWorkWithError:&amp;amp;error completeBlock:bb];
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;


但是不管以上哪两种方法`viewModel`的对象方法必须改成`- (void)getNetWorkWithError:(NSError * __strong *)error completeBlock:(void(^)(void))block`。



这样就可以正确打印我们想要的效果。



## 原因

1.首先第一种思路，原因不必多说了，将error提升到全部静态变量，在代码的任何地方都能轻易地访问到本尊，也就是没有我接下去讲的那么多破事了（block不capture静态变量），所以一句话带过，要是你对代码有洁癖，不想随意开辟全局空间，那就看看第二种思路。



2.首先，编译器会把``__block`` 修饰``error``对象变成一个结构体，而对于第二种写法为什么要先申明好`block`,再作为参数塞入呢，主要是因为`` void(^bb)(void) = ^{NSLog(@&quot;%@&quot;,error);};``，`arc`环境下基本没有`stackBlock`，看到的`block`基本都是`mallocBlock`或者`globalBlock`。所以这句话因为`block`通过`copy` 捕获到的`error`上升到堆空间,所以如果开始这么写的显然是不对的。

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[viewModel getNetWorkWithError:&amp;amp;error completeBlock:^(){
		NSLog(@”%@”,error);
}];&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;


通过clang转换cpp可得知:

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;((void (&lt;em&gt;)(id, SEL, NSError **, void (&lt;/em&gt;)()))(void &lt;em&gt;)objc_msgSend)((id)viewModel, sel_registerName(“getNetWorkWithError:completeBlock:”), &amp;amp;(error.__forwarding-&amp;gt;error), ((void (&lt;/em&gt;)())&amp;amp;__netWork_block_impl_0((void *)__netWork_block_func_0, &amp;amp;__netWork_block_desc_0_DATA, (__Block_byref_error_0 *)&amp;amp;error, 570425344)));&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
首个参数（error的二级指针），入参时还是栈空间地址。执行到下方`block`参数时，才上升到堆空间。这么写，两个error的地址其实不是一个，所以在这里对调用的时机有了更严格的要求。



3.关于二级指针为什么默认是``__autorelease``对象，然后这里必须改成 `__strong`修饰，原因我用自己的话总结了一下，

首先第一点，我们先搞清楚，为什么在这种需求下，必须这么写。因为用了``__autorelease``修饰的外部参数，是用到了一个传递回写的机制（[pass-by-writeback](https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-ownership-restrictions-pass-by-writeback) 官方clang文档 4.3.3明确有提到）, 类似于这样（引用自[iOS开发Tips：objective-c指针解引用](https://www.jianshu.com/p/1dc7c31fa06f)）：

```ruby
__strong NSObject *o;
__autoreleasing NSObject *temp = o;  
[self method2:&amp;amp;temp]; 
o = temp;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译器帮我生成一个临时的变量传入方法，最后回写到我们原来的对象上。&lt;/p&gt;

&lt;p&gt;这就是解释了，为什么采用默认写法会有问题：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void)getNetWorkWithError:(NSError **)error completeBlock:(void(^)(void))block {
		NSLog(@&quot;error is %p&quot;, &amp;amp;*error);
		//...延迟操作error...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在方法内部和方法外部打印一下指针的地址，就一目了然了，不是一个对象指针对象。&lt;/p&gt;

&lt;p&gt;因此默认写法肯定就没用了。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;__strong NSObject *o;
__autoreleasing NSObject *temp = o;  
[self method2:&amp;amp;temp]; //temp在方法内部延迟操作。
o = temp;//在这里赋值时temp还是nil，导致o始终是nil
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以先说结论，改成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_strong&lt;/code&gt;修饰二级指针之后，编译器不会再出现回写操作，我特意打了地址试了一下。&lt;/p&gt;

&lt;p&gt;到此，我们可以知道，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt;被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__block&lt;/code&gt;修饰以及被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy&lt;/code&gt;到堆上，禁掉回写逻辑，从始至终都只有一个指针对象在传来传去，所以这段逻辑到此就没什么问题了。&lt;/p&gt;

&lt;h2 id=&quot;后续&quot;&gt;后续&lt;/h2&gt;

&lt;p&gt;现在可以来讨论一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__autorelease&lt;/code&gt;了，苹果为什么要这么设计。&lt;a href=&quot;https://www.cnblogs.com/tiantianbobo/p/11653843.html&quot;&gt;一道题考你对__autoreleasing和__block的理解 &lt;/a&gt; 和&lt;a href=&quot;https://clang.llvm.org/docs/AutomaticReferenceCounting.html&quot;&gt;clang原文&lt;/a&gt;其实已经讲得非常清楚了，但是第一次读还是觉得有点绕，用自己的话解释一下。&lt;/p&gt;

&lt;p&gt;当方法有返回参数的时候，默认都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__autorelease&lt;/code&gt;的，这个很好理解，尤其是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mrc&lt;/code&gt;环境下当你&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;一个对象 给外部调用时，默认应该是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;状态的，当你返回出去的时候&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;是 + 1 ，+ 2 ，+3 …那你让谁来处理呢？这显然是不合理的。&lt;/p&gt;

&lt;p&gt;所以，二级指针也是调用方法返回参数的其中一种方法，同样应该保持同样的性质。&lt;/p&gt;

&lt;p&gt;而同在ARC和MRC两种环境下用这种方式互相调用的，苹果也有进一步的优化了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-189840a28bbf8fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2205796-ae292967248756e9.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我觉得这张图非常好，最近刚看到，绝对过目不忘。&lt;/p&gt;

&lt;p&gt;鸣谢:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.sunnyxx.com/2014/10/15/behind-autorelease/&quot;&gt;黑幕背后的Autorelease&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tiantianbobo/p/11653843.html&quot;&gt;一道题考你对__autoreleasing和__block的理解 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://clang.llvm.org/docs/AutomaticReferenceCounting.html&quot;&gt;clang原文&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Oct 2020 15:12:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/30/%E4%B8%80%E6%AC%A1%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/30/%E4%B8%80%E6%AC%A1%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/</guid>
        
        <category>iOS,block</category>
        
        
      </item>
    
      <item>
        <title>重读YYImage</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;实至今日，才发现自己的能力在各方面和牛逼的人差距还是挺大的。计算机的很多基础知识都很薄弱。&lt;/p&gt;

&lt;p&gt;其实15年刚刚做iOS的时候就接触过YYImage，但也没有好好读过源码。&lt;/p&gt;

&lt;p&gt;最近因为业务需要，对各种图片格式也有了新的认识，索性重新来读一遍YYImage，顺便总结一些感想&lt;/p&gt;

&lt;p&gt;YYImage是YYKit系列中的其中一个组件。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;其实纵观整个YYImage还是基于ImageIO和CoreGraphics的相关api进行一系列操作的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加载一张普通静态图的大致步骤:
    &lt;ol&gt;
      &lt;li&gt;通过分辨率和图片格式加载图片进内存&lt;/li&gt;
      &lt;li&gt;通过源数据判断判断图片类型&lt;/li&gt;
      &lt;li&gt;通过图片类型进行源数据的信息获取，这里作者大概分为三类，webp:依赖于&lt;a href=&quot;https://developers.google.com/speed/webp/&quot;&gt;libwebp&lt;/a&gt; ,png和apng作者自己写了一套数据解析的算法（这里我暂时放弃了..下次一定学）,剩下的都基于ImageIO，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_YYImageDecoderFrame&lt;/code&gt;私有属性保存源数据信息。&lt;/li&gt;
      &lt;li&gt;调用ImageIO相关api进行解码，之后就可以愉快地使用了。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;加载一张动图的大致步骤:
    &lt;ol&gt;
      &lt;li&gt;和加载静态的图流程差不多，源数据会多记录一些东西，比如每一帧的druation，每一帧的渲染方式。详见&lt;a href=&quot;https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/&quot;&gt;这篇&lt;/a&gt;，原作者讲的很详细（在解码动图时，解码器通常采用所谓“画布模式”进行渲染。想象一下：播放的区域是一张画布，第一帧播放前先把画布清空，然后完整的绘制上第一帧图；播放第二帧时，不再清空画布，而是只把和第一帧不同的区域覆盖到画布上，就像油画的创作那样。像这样的第一帧就被称为关键帧（即 I 帧，帧内编码帧），而后续的那些通过补偿计算得到的帧被称为预测编码帧（P帧）。一个压缩的比较好的动图内，通常只有少量的关键帧，而其余都是预测编码帧；一个较差的压缩工具制作的动图内，则基本都是关键帧。不同的动图压缩工具通常能得到不同的结果。）这些其实都很详细地记录在图片的原数据里。&lt;/li&gt;
      &lt;li&gt;显示动图必须用YYAnimatedImageView承接，用UIImageView只会显示第一帧（这是YYImage内部实现的原因），每个YYAnimatedImageView里都有一个CADisplayLink，通过屏幕绘制频率进行进度计算和异步解码。实现边播放边解码的高性能操作。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;疑点总结&quot;&gt;疑点总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于动图来说，假设其中一帧进度时间小于0.011秒，强制将这一帧时间提升到0.1秒。至于原因其实源码当中是有备注的。&lt;/p&gt;

    &lt;p&gt;大致原因在于：许多恼人的广告指定0秒持续时间，以到达最快速度的闪烁，我们遵循Safari和Firefox的行为，对于指定持续时间&amp;lt;=10毫秒的任何帧，使用100毫秒的持续时间&lt;/p&gt;

    &lt;p&gt;这也是ImageIO源码中的原话&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// Many annoying ads specify a 0 duration to make an image flash as quickly as possible.
// We follow Firefox&apos;s behavior and use a duration of 100 ms for any frames that specify
// a duration of &amp;lt;= 10 ms. See &amp;lt;rdar://problem/7689300&amp;gt; and &amp;lt;http://webkit.org/b/36082&amp;gt;
// for more information.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;至于为什么是100毫秒，下面其实也有说到，&lt;/p&gt;

    &lt;p&gt;没有一个现代浏览器支持0.02秒以下的帧延迟。因此，当创建动画GIF时，绝不应使用低于此阈值的帧延迟，因为这将完全无效。另一个有趣的发现是Safari是唯一一个在GIF动画播放方面性能下降的浏览器。&lt;/p&gt;

    &lt;p&gt;对于那些对创建和观看流畅、快速的动画感兴趣的人来说，Chrome、Firefox和Opera无疑是不错的选择。这些浏览器都支持0.02秒的最小帧延迟，从而使动画GIF以每秒50帧的速度运行。然而，这种能力需要与交叉兼容性问题进行权衡。&lt;/p&gt;

    &lt;p&gt;由于Safari和internetexplorer决定只支持0.06秒的帧延迟（低于此值的四舍五入为0.10秒），动画的观看速度有可能大大低于预期。所讨论的GIF将以每秒10帧的速度播放，而不是期望的每秒50帧。只有20%的真实速度，这成为一个认真考虑美学影响。（翻译而来差不多看看）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于单张静态图片的加载，YYImage和UImage的加载方式略有不同，同样是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imageNamed:(NSString *)name&lt;/code&gt;方法，UImage不会解码，而是在UIImageView addView的时候才进行解码，而YYImage会在调用该方法后当场解码，因此放入异步线程进行解码还可以减少主线程压力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;几种常见的图片保存格式&lt;/p&gt;

    &lt;p&gt;第一种是 baseline，即逐行扫描。默认情况下，JPEG、PNG、GIF 都是这种保存方式。
第二种是 interlaced，即隔行扫描。PNG 和 GIF 在保存时可以选择这种格式。
第三种是 progressive，即渐进式。JPEG 在保存时可以选择这种方式。
调用CGImageSourceUpdateData(data, false) 可以实现类似于网页中的渐进式显示的效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preloadAllAnimatedImageFrames&lt;/code&gt;该属性可支持提前解开所有帧图片，使在动图播放过程中减少cpu的开销，但是可能会造成oom，所以视情况而定进行使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强如webp也有他的性能瓶颈，那就是解码效率，没有方案是万能的，bitmap，png，wep各自都有他们的存在场景，假如以后计算机的存储量和网络流量都无限大，随便用，那么我完全可以使用bitmap，我为什么要使用webp去消耗额外的cpu或者gpu的开销呢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其实YYImage当中还有很强大的encode功能，支持多种格式和参数（quality质量，lossless无损等），不过我个人在实际业务中用到的比较少。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;遗留问题&quot;&gt;遗留问题&lt;/h2&gt;

&lt;p&gt;读源码的过程中还是碰到某几处地方还是没有特别的理解，希望后续有机会能得到答案&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;关于在解码类的入口函数递归锁的使用&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (BOOL)updateData:(NSData *)data final:(BOOL)final {
    BOOL result = NO;
    pthread_mutex_lock(&amp;amp;_lock);
    result = [self _updateData:data final:final];
    pthread_mutex_unlock(&amp;amp;_lock);
    return result;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;我认为对于递归锁的本质来说，其实就是给递归方法用的。使得同一线程在同一区块可以进行重入，但是对于该方法，我来来回回看了很多遍都没发现怎么会出现重入的情况，所以对于这里还是挺疑惑的，这里用递归锁的意义。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关于缓冲区的下一帧的移除操作&lt;/p&gt;

    &lt;p&gt;在CADisplayLink每次触发的step方法中有这么一段&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bufferedImage = buffer[@(nextIndex)];
if (bufferedImage) {
	if ((int)_incrBufferCount &amp;lt; _totalFrameCount) {
		[buffer removeObjectForKey:@(nextIndex)];
	}
....
} else {
		_bufferMiss = YES;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;经过多次的调试，没太明白&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[buffer removeObjectForKey:@(nextIndex)]&lt;/code&gt;这句话的意义，因为由于子线程的解码速度一定是大于当前播放的帧数的，所以其实每次每次来到这个地方，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextIndex&lt;/code&gt;基本是解完了的，但这里先是在buffer中移除下一帧图片，但后续又在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operation&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;重新拿到(虽然有缓存)进行添加的，因为buffer最终还是会保存所有的帧图片。而且我移除这句话也没发现啥问题，所以没有很搞懂移除的操作是为了啥&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;待学部分:png的图片格式数据解析，包括图片的解码算法。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;感谢&quot;&gt;感谢&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/&quot;&gt;移动端图片格式调研&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.ibireme.com/2015/11/02/ios_image_tips/&quot;&gt;iOS 处理图片的一些小 Tip&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Sep 2020 11:30:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/20/%E9%87%8D%E8%AF%BBYYImage%E6%9C%89%E6%84%9F/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/20/%E9%87%8D%E8%AF%BBYYImage%E6%9C%89%E6%84%9F/</guid>
        
        <category>YYImage</category>
        
        
      </item>
    
      <item>
        <title>block hook</title>
        <description>&lt;h2 id=&quot;导言&quot;&gt;导言&lt;/h2&gt;

&lt;p&gt;block作为oc极为重要的一部分从来都是面试和开发乐此不疲的话题与工具。&lt;/p&gt;

&lt;p&gt;关于block的数据结构和实现原理网上大大小小真的已经很多了，这里不再叙述，最近有业务需求需要hook block 进行一些无埋点的监控，所以顺便记录下学习过程。&lt;/p&gt;

&lt;h2 id=&quot;方案&quot;&gt;方案&lt;/h2&gt;

&lt;h3 id=&quot;当前blockhook的方案大致有两种&quot;&gt;当前&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blockhook&lt;/code&gt;的方案大致有两种:&lt;/h3&gt;

&lt;h4 id=&quot;1基于libffi的blockhook&quot;&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;1.基于libffi的blockhook&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;libffi的原理和用法这里不予赘述了。&lt;/p&gt;

&lt;p&gt;大致流程:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据 block 对象的签名，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ffi_prep_cif&lt;/code&gt; 构建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; block-&amp;gt;invoke &lt;/code&gt;函数的模板 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cif&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ffi_closure&lt;/code&gt;，根据 cif 动态定义函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replacementInvoke&lt;/code&gt;，绑定到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClosureFunc&lt;/code&gt;(一个具体实现的函数实体上)&lt;/li&gt;
  &lt;li&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; block-&amp;gt;invoke &lt;/code&gt;替换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replacementInvoke&lt;/code&gt;，原始的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block-&amp;gt;invoke&lt;/code&gt; 存放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;originInvoke&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClosureFunc&lt;/code&gt; 中通过hook位置动态调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;originInvoke&lt;/code&gt; 函数和执行 hook 的逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;2基于方法转发的blockhook&quot;&gt;&lt;a href=&quot;https://github.com/welcommand/FishBind&quot;&gt;2.基于方法转发的blockhook&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;大致流程:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runtime&lt;/code&gt;交换block对象的方法转发的方法。&lt;/li&gt;
  &lt;li&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; block-&amp;gt;invoke &lt;/code&gt;替换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(IMP)_objc_msgForward&lt;/code&gt;，重新拷贝原block生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;newBlock&lt;/code&gt;，通过关联对象进行保存(block地址为key)。&lt;/li&gt;
  &lt;li&gt;在自定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;方法转发&lt;/code&gt;方法中拿到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;newBlock&lt;/code&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;originInvoke&lt;/code&gt; 函数进行调用和执行 hook 的逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;问题总结&quot;&gt;问题总结&lt;/h2&gt;

&lt;p&gt;1.其实两种方法在思路是差不多的，都是通过’曲线救国’的方式，找到那个中间的桥接函数，进行替换。区别在于实现方法不同。&lt;/p&gt;

&lt;p&gt;上述的第一种方法，优点是目前比较稳定，功能强大，且兼容了在各种环境下的很多问题，缺点是要引libffi。&lt;/p&gt;

&lt;p&gt;第二种的方式较轻量，且不用引libffi，但没有像第一种经过大量的验证，兼容性有待测试。&lt;/p&gt;

&lt;p&gt;2.在第二种方式中，我发现作者对于原&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;originInvoke&lt;/code&gt;的处理麻烦了，不需要重新new一份新的内存和拷贝。直接保存&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;originInvoke&lt;/code&gt;的通过关联对象保存原函数指针，在调用过程中再换回来就可以。&lt;/p&gt;

&lt;p&gt;伪代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;-(void)blockhook{
    //交换方法..
    ...
    //保存block原实现
		[self saveOriginInvoke:block-&amp;gt;invoke];	
    //替换block实现
    block-&amp;gt;invoke = _objc_msgForward; 
}

-(void)bh_forwardInvocation:(NSInvocation *)invocation{
    
    //hook逻辑
    ...
    //替换回原实现
    block-&amp;gt;invoke = [self getOriginInvoke];
    //执行原逻辑函数
    [invocation invokeWithTarget:block];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.将target设置为iOS13,运行时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalBlock&lt;/code&gt;类型会出现invoke替换问题，而另外两张类型的block没问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-b4586ec4d33fc875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开始也是百思不得其解，想了各种办法，想试着通过结构体的地址偏移量去修改invoke依然换不掉，开始觉得可能是底层偷偷把地址换了，看了汇编把寄存器值打印出来发现地址也对，但写入就是坏地址访问。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2782305-4934167dcbfecf44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;走投无路之际看到了第一位作者的文章才恍然大悟，不得不佩服大佬的才华。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2020/05/30/BlockHook-and-Memory-Safety/&quot;&gt;BlockHook and Memory Safety&lt;/a&gt; 文中提到如何解决 GlobalBlock 没有写权限的问题。用到了虚拟内存的一些相关api去修改内存页的读写权限，经过代码运行，我也证实了确实苹果在iOS13将GlobalBlock权限进行了限制，只有只读权限，至于为啥求大佬们解惑。以下是解决方案&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;vm_prot_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;protectInvokeVMIfNeed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vm_address_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm_address_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vm_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vmsize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mach_port_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if defined(__LP64__) &amp;amp;&amp;amp; __LP64__
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vm_region_basic_info_data_64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mach_msg_type_number_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infoCnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VM_REGION_BASIC_INFO_COUNT_64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;kern_return_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_region_64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mach_task_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vmsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VM_REGION_BASIC_INFO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm_region_info_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;infoCnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vm_region_basic_info_data_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mach_msg_type_number_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infoCnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VM_REGION_BASIC_INFO_COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;kern_return_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mach_task_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vmsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VM_REGION_BASIC_INFO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm_region_info_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;infoCnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KERN_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;vm_region block invoke pointer failed! ret:%d, addr:%p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VM_PROT_NONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vm_prot_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VM_PROT_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_protect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mach_task_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm_address_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VM_PROT_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KERN_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;vm_protect block invoke pointer VM_PROT_WRITE failed! ret:%d, addr:%p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VM_PROT_NONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;核心函数是下面这个，直接贴文档。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Function - Set access privilege attribute for a region of virtual memory.

SYNOPSIS
kern_return_t   vm_protect
                 (vm_task_t           target_task,（需要修改的内存空间区域）
                  vm_address_t            address,（起始地址）
                  vm_size_t                  size,（地址大小）
                  boolean_t           set_maximum, （这个没太看懂）
                  vm_prot_t        new_protection); (赋予的新的权限)
PARAMETERS
target_task
[in task send right] The port for the task whose address space contains the region.
address
[in scalar] The starting address for the region.
size
[in scalar] The number of bytes in the region.
set_maximum
[in scalar] Maximum/current indicator. If true, the new protection sets the maximum protection for the region. If false, the new protection sets the current protection for the region. If the maximum protection is set below the current protection, the current protection is also reset to the new maximum.
new_protection
[in scalar] The new protection for the region. Valid values are obtained by or&apos;ing together the following values:
VM_PROT_READ
Allows read access.
VM_PROT_WRITE
Allows write access.
VM_PROT_EXECUTE
Allows execute access.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此在iOS13也可以开心的玩耍了。&lt;/p&gt;

&lt;p&gt;剩下的实现包括读取参数，获取方法签名包装这些相关文档已经太多了，就不多赘述了。&lt;/p&gt;

&lt;p&gt;看别人的方案就是这样。内心的os都是:哇还可以这么玩，为什么我想不到😭&lt;/p&gt;

&lt;p&gt;我自己也基于第二种方法,并且结合以上的问题，做了些修改，撸了一个分类。目前自己在项目中debug用用感觉还不错&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Wbqqqq/BQBlockHook&quot;&gt;超简易版BlockHook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本次学习非常感谢:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yulingtianxia/BlockHook&quot;&gt;BlockHook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/welcommand/FishBind&quot;&gt;FishBind&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2020/05/30/BlockHook-and-Memory-Safety/&quot;&gt;BlockHook and Memory Safety&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/&quot;&gt;Hook Objective-C Block with Libffi&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 15 Sep 2020 11:30:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/15/BlockHook/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/15/BlockHook/</guid>
        
        <category>block</category>
        
        
      </item>
    
  </channel>
</rss>
